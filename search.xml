<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>再也不用为中文输入法而烦恼了</title>
      <link href="/d/cloverpinyin/"/>
      <url>/d/cloverpinyin/</url>
      
        <content type="html"><![CDATA[<p>你是否经历过搜狗输入法总是闪退bug的绝望？</p><p>你是否经历过 fcitx 自带输入法的词库简陋？</p><p>你是否经历过在 linux 中尝试各种输入法都不理想呢？</p><p>这里是帮你脱离苦海的地方。</p><a id="more"></a><h1 id="四叶草拼音输入方案"><a class="markdownIt-Anchor" href="#四叶草拼音输入方案"></a> 🍀四叶草拼音输入方案</h1><h1 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h1><ul><li><a href="#four_leaf_clover%E5%9B%9B%E5%8F%B6%E8%8D%89%E6%8B%BC%E9%9F%B3%E8%BE%93%E5%85%A5%E6%96%B9%E6%A1%88">🍀四叶草拼音输入方案</a></li><li><a href="#%E7%9B%AE%E5%BD%95">目录</a><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E7%89%B9%E8%89%B2">特色</a></li><li><a href="#%E5%BC%80%E5%A7%8B">开始</a><ul><li><a href="#linux%E7%AB%AF-fcitx-">linux端( fcitx )</a><ul><li><a href="#%E5%AE%89%E8%A3%85-fcitx">安装 fcitx</a></li><li><a href="#%E5%AE%89%E8%A3%85-rime">安装 rime</a></li><li><a href="#%E5%AE%89%E8%A3%85four_leaf_clover%E5%9B%9B%E5%8F%B6%E8%8D%89%E8%BE%93%E5%85%A5%E6%96%B9%E6%A1%88">安装🍀四叶草输入方案</a></li><li><a href="#%E7%BE%8E%E8%A7%82">美观</a></li></ul></li><li><a href="#windows%E7%AB%AF%E5%B0%8F%E7%8B%BC%E6%AF%AB">windows端（小狼毫）</a><ul><li><a href="#%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E5%B0%8F%E7%8B%BC%E6%AF%AB">下载安装小狼毫</a></li><li><a href="#%E4%B8%8B%E8%BD%BD%E8%BE%93%E5%85%A5%E6%96%B9%E6%A1%88">下载输入方案</a></li><li><a href="#%E7%BE%8E%E8%A7%82-1">美观</a></li><li><a href="#%E5%80%99%E9%80%89%E6%A8%AA%E6%8E%92">候选横排</a></li></ul></li><li><a href="#%E5%85%B3%E4%BA%8E%E5%8F%91%E5%B8%83%E9%A1%B5">关于发布页</a></li></ul></li><li><a href="#%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE">基本配置</a><ul><li><a href="#%E5%80%99%E9%80%89%E8%AF%8D%E4%B8%AA%E6%95%B0">候选词个数</a></li><li><a href="#%E6%A8%A1%E7%B3%8A%E9%9F%B3">模糊音</a></li></ul></li><li><a href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">常见问题</a><ul><li><a href="#%E5%90%84%E7%A7%8D%E5%BF%AB%E6%8D%B7%E9%94%AE">各种快捷键</a></li><li><a href="#%E5%87%BA%E7%8E%B0%E5%80%99%E9%80%89%E6%A1%86%E6%97%B6%E6%8C%89-shift-%E5%AD%97%E6%AF%8D%E4%B8%8D%E4%BC%9A%E4%B8%8A%E5%B1%8F">出现候选框时按 Shift 字母不会上屏</a></li><li><a href="#%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E8%87%AA%E9%80%A0%E8%AF%8D">删除一个自造词</a></li><li><a href="#%E8%AF%8D%E5%BA%8F%E6%80%BB%E6%98%AF%E9%94%99%E4%B9%B1">词序总是错乱</a></li><li><a href="#emoji-%E5%AD%97%E4%BD%93%E5%91%88%E6%96%B9%E5%9D%97%E7%8A%B6">emoji 字体呈方块状</a></li><li><a href="#%E5%AF%BC%E5%85%A5%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%8D%E5%BA%93">导入自定义词库</a><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4">基本步骤</a></li><li><a href="#%E4%BE%8B%E5%AD%90%E8%AF%A6%E8%A7%A3">例子详解</a></li></ul></li><li><a href="#%E5%90%8C%E6%AD%A5%E8%AF%8D%E5%BA%93">同步词库</a></li><li><a href="#%E5%85%B6%E5%AE%83">其它</a></li></ul></li><li><a href="#%E6%9E%84%E5%BB%BA">构建</a></li><li><a href="#%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E">写在最后</a></li></ul></li></ul><p>Created by <a href="https://github.com/ekalinin/github-markdown-toc" target="_blank" rel="noopener">gh-md-toc</a></p><h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><p>在linux端，很多拼音输入法有少许 bug 或卡顿，或功能不全，所以接触了 <a href="https://rime.im" target="_blank" rel="noopener">rime</a> ，然而自带的<a href="https://github.com/rime/rime-luna-pinyin" target="_blank" rel="noopener">朙月拼音</a>和<a href="https://github.com/rime/rime-pinyin-simp" target="_blank" rel="noopener">袖珍簡化字拼音</a>均不是很不是很理想，但是探索过程中发现很多很好的开源项目提供词库，而 rime 输入法引擎几乎拥有所有的优点（开源、干净无广告、运行流畅、跨平台、…），甚至云同步也能用坚果云之类的服务手动实现，唯一的缺点就是门槛高定制困难，默认配置的不习惯劝退了很多人。</p><p>在此方案诞生之前，我没能找到一个比较不错的简体拼音（全拼）的输入方案，多数人用惯了大陆国产的输入法，而以我的动手能力，完全能够按照这些输入法的习惯，自己定制一个方案，共享给更多的人，让更多的人不需要怎么配置也能用上非常类似于搜狗拼音输入法的方案，尽可能开箱即用，降低所有人的使用门槛。所以，为什么不自己做一个呢？</p><p><strong>这个项目我会持续更新，因为我一直在用输入法，我会调教到完全合我的口味习惯为止（我过去一直在用搜狗拼音输入法）。所以如果你觉得哪里不好用，或者哪里想改善，一定要及时在 <a href="https://github.com/fkxxyz/rime-cloverpinyin/issues" target="_blank" rel="noopener">issues</a> 提出，我只要看到就会回复。</strong></p><ul><li><p>博文地址<a href="https://www.fkxxyz.com/d/cloverpinyin" target="_blank" rel="noopener">https://www.fkxxyz.com/d/cloverpinyin</a></p></li><li><p>项目地址<a href="https://github.com/fkxxyz/rime-cloverpinyin" target="_blank" rel="noopener">https://github.com/fkxxyz/rime-cloverpinyin</a></p></li></ul><h2 id="特色"><a class="markdownIt-Anchor" href="#特色"></a> 特色</h2><p>我亲自打造的基于<a href="https://rime.im/" target="_blank" rel="noopener">rime</a>的简体拼音输入方案，有以下几大特点：</p><ol><li><p>完全从零开始制作文字的拼音和基础词库，导入了几个很好用的词库：</p><ul><li>用 <a href="https://github.com/mozillazg/python-pinyin" target="_blank" rel="noopener">pypinyin</a> 项目生成所有字词的拼音</li><li>合并<a href="https://github.com/fxsjy/jieba" target="_blank" rel="noopener">结巴中文分词</a>项目、<a href="https://github.com/rime/rime-essay" target="_blank" rel="noopener">rime八股文</a>和<a href="https://github.com/rime/rime-pinyin-simp" target="_blank" rel="noopener">袖珍簡化字拼音</a>的字的字频</li><li>由百度搜索到某个人基于大数据做过的<a href="https://download.csdn.net/download/xmp3x/8621683" target="_blank" rel="noopener">360万中文词库+词性+词频</a>，该词库是用ansj分词对270G新闻语料进行分词统计词频获得</li><li><a href="https://github.com/thunlp/THUOCL" target="_blank" rel="noopener">清华大学开源词库</a>，统计来自各大主流网站如CSDN博客、新浪新闻、搜狗语料</li><li>搜狗细胞词库 <a href="https://pinyin.sogou.com/dict/detail/index/4" target="_blank" rel="noopener">网络流行新词【官方推荐】</a></li></ul></li><li><p>词库本身基于简体，并且加入繁简切换，包括自定义词库也能切换繁体（朙月拼音输入简体时的需要经过opencc转换，而且自定义词库也得手动转换成繁体才能繁简切换，而袖珍簡化字拼音不支持繁体）</p></li><li><p>默认加入 emoji 表情输入支持</p><p><img src="https://www.fkxxyz.com/img/cloverpinyin-1.png" alt="" /></p></li><li><p>加入拼音输入特殊符号的支持（如输入 pingfang 即可打出 ²）</p><p><img src="https://www.fkxxyz.com/img/cloverpinyin-2.png" alt="" /></p><p><a href="https://github.com/fkxxyz/rime-symbols" target="_blank" rel="noopener">rime-symbols</a> 该模块与此项目独立，你也可以把这个模块放到别的方案上用。</p></li><li><p>修改了几乎所有特殊符号的按键，定制全部快捷键，使之符合搜狗输入法的习惯</p></li></ol><p>不磨蹭了，直接介绍怎么开始使用吧。</p><h2 id="开始"><a class="markdownIt-Anchor" href="#开始"></a> 开始</h2><p>rime 是跨平台的，在以下四个平台可用：</p><ul><li><p><strong>linux</strong> 可以使用 fcitx、fxitx5、ibus</p></li><li><p><strong>windows</strong> 使用小狼毫</p></li><li><p><strong>macOS</strong> 可以用鼠鬚管</p></li><li><p><strong>安卓</strong> 使用同文输入法</p></li></ul><p>这些软件如果你想在这些平台使用，可以具体参照官方的<a href="https://rime.im/download/" target="_blank" rel="noopener">下载安装说明</a></p><hr /><p>下面介绍在 linux 和 windows 端如何安装。</p><h3 id="linux端-fcitx"><a class="markdownIt-Anchor" href="#linux端-fcitx"></a> linux端( fcitx )</h3><h4 id="安装-fcitx"><a class="markdownIt-Anchor" href="#安装-fcitx"></a> 安装 fcitx</h4><p>在 archlinux 下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S fcitx fcitx-qt5 fcitx-configtool</span><br></pre></td></tr></table></figure><p>然后配置 fcitx 的环境变量</p><p>在 ~/.xprofile 写入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export GTK_IM_MODULE=fcitx</span><br><span class="line">export QT_IM_MODULE=fcitx</span><br><span class="line">export XMODIFIERS="@im=fcitx"</span><br><span class="line"></span><br><span class="line">export LANG="zh_CN.UTF-8"</span><br><span class="line">export LC_CTYPE="zh_CN.UTF-8"</span><br></pre></td></tr></table></figure><p>其他发行版的安装参见 <a href="https://fcitx-im.org/wiki/Install_and_Configure/zh-hans" target="_blank" rel="noopener">小企鹅官网安装配置方法</a></p><p>安装和配置完成后，记得重新登录桌面使之生效。</p><h4 id="安装-rime"><a class="markdownIt-Anchor" href="#安装-rime"></a> 安装 rime</h4><p>在 archlinux 下，安装 rime：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S fcitx-rime</span><br></pre></td></tr></table></figure><p>其他发行版请用相应的包管理器安装，详见 <a href="https://rime.im/download/" target="_blank" rel="noopener">https://rime.im/download/</a></p><h4 id="安装四叶草输入方案"><a class="markdownIt-Anchor" href="#安装四叶草输入方案"></a> 安装🍀四叶草输入方案</h4><p>在 archlinux 下，可以从 <a href="https://wiki.archlinux.org/index.php/Arch_User_Repository_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">AUR</a> 直接安装即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S fcitx-cloverpinyin</span><br></pre></td></tr></table></figure><p>在其它发行版下，来发布页 <a href="https://github.com/fkxxyz/rime-cloverpinyin/releases" target="_blank" rel="noopener">https://github.com/fkxxyz/rime-cloverpinyin/releases</a> 或 <a href="https://fkxxyz.lanzous.com/b00zl958j" target="_blank" rel="noopener">https://fkxxyz.lanzous.com/b00zl958j</a> 下载最新版本的配置文件，如 clover.schema-1.1.0.zip</p><p>然后将其解压到 ~/.config/fcitx/rime</p><p>创建 ~/.config/fcitx/rime/default.custom.yaml ，内容为</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">patch:</span></span><br><span class="line">  <span class="attr">"menu/page_size":</span> <span class="number">8</span></span><br><span class="line">  <span class="attr">schema_list:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">schema:</span> <span class="string">clover</span></span><br></pre></td></tr></table></figure><p>其中 8 表示打字的时候输入面板的每一页的候选词数目，可以设置成 1~9 任意数字。</p><p>写好该文件之后，点击右下角托盘图标右键菜单，点“重新部署”，然后再点右键，在方案列表里面应该就有“ �️四叶草拼音输入法”的选项了。</p><p>关于 default.custom.yaml 文件的更多解释，可以参考<a href="https://github.com/rime/home/wiki/CustomizationGuide" target="_blank" rel="noopener">官方文档定制指南</a></p><h4 id="美观"><a class="markdownIt-Anchor" href="#美观"></a> 美观</h4><p>关于 fcitx 的皮肤，可以参考这里：</p><p><a href="https://www.fkxxyz.com/d/ssfconv/" target="_blank" rel="noopener">原来 fcitx 也可以这么美 —— 对 fcitx 使用搜狗皮肤的改进</a></p><h3 id="windows端小狼毫"><a class="markdownIt-Anchor" href="#windows端小狼毫"></a> windows端（小狼毫）</h3><h4 id="下载安装小狼毫"><a class="markdownIt-Anchor" href="#下载安装小狼毫"></a> 下载安装小狼毫</h4><p>来 <a href="https://rime.im/download/" target="_blank" rel="noopener">rime下载页</a> 下载最新版本的小狼毫（注意 Windows XP 只最高只能下载 0.12.0），然后按照提示进行安装。</p><h4 id="下载输入方案"><a class="markdownIt-Anchor" href="#下载输入方案"></a> 下载输入方案</h4><p>来发布页 <a href="https://github.com/fkxxyz/rime-cloverpinyin/releases" target="_blank" rel="noopener">https://github.com/fkxxyz/rime-cloverpinyin/releases</a> 或 <a href="https://fkxxyz.lanzous.com/b00zl958j" target="_blank" rel="noopener">https://fkxxyz.lanzous.com/b00zl958j</a> 下载最新版本的配置文件，如 clover.schema-1.1.0.zip</p><p>然后将其解压到 %appdata%/rime 即可（如果你更改了用户配置目录，那么解压到对应目录即可）。</p><p>然后切换到中州韵输入法，右键托盘图标，点击输入法设定，勾选上四叶草输入方案，确定，再点右键托盘图标，重新部署，等待数分钟后，即可使用。</p><h4 id="美观-2"><a class="markdownIt-Anchor" href="#美观-2"></a> 美观</h4><p>小狼毫的字体、配色方案参考 <a href="https://github.com/rime/home/wiki/CustomizationGuide#%E4%B8%80%E4%BE%8B%E5%AE%9A%E8%A3%BD%E5%B0%8F%E7%8B%BC%E6%AF%AB%E5%AD%97%E9%AB%94%E5%AD%97%E8%99%9F" target="_blank" rel="noopener">官方配置指南–小狼毫</a></p><h4 id="候选横排"><a class="markdownIt-Anchor" href="#候选横排"></a> 候选横排</h4><p>候选词默认展示是竖排的，如果你习惯于横排展示候选词，请看 <a href="https://github.com/rime/home/wiki/CustomizationGuide#%E5%B0%8F%E7%8B%BC%E6%AF%AB%E5%A4%96%E8%A7%80%E8%A8%AD%E5%AE%9A" target="_blank" rel="noopener">【小狼毫】外觀設定</a></p><p>方便起见，在此也附上网页版的配置链接 <a href="https://bennyyip.github.io/Rime-See-Me/" target="_blank" rel="noopener">RIME西米</a></p><h3 id="关于发布页"><a class="markdownIt-Anchor" href="#关于发布页"></a> 关于发布页</h3><p>由于 rime 处理词库的原理是提前将词库转换为二进制文件，这个过程成为部署，所以我在<a href="https://github.com/fkxxyz/rime-cloverpinyin/releases" target="_blank" rel="noopener">发布页</a>提供了两个压缩包，一个包含二进制文件，一个不包含二进制文件。</p><ul><li><strong>clover.schema</strong> 不包含二进制文件，复制到新机器上之后需要重新部署。</li><li><strong>clover.schema-build</strong> 包含二进制文件目录（build目录），复制到新机器上之后重新部署的时间大量缩短。</li></ul><p>由于国内访问 github 较慢，所以我在蓝奏云也上传了一份 <a href="https://fkxxyz.lanzous.com/b00zl958j" target="_blank" rel="noopener">https://fkxxyz.lanzous.com/b00zl958j</a></p><h2 id="基本配置"><a class="markdownIt-Anchor" href="#基本配置"></a> 基本配置</h2><p>所有配置都围绕着用户资料夹展开，参考 <a href="https://github.com/rime/home/wiki/RimeWithSchemata#rime-%E4%B8%AD%E7%9A%84%E6%95%B8%E6%93%9A%E6%96%87%E4%BB%B6%E5%88%86%E4%BD%88%E5%8F%8A%E4%BD%9C%E7%94%A8" target="_blank" rel="noopener">Rime 中的數據文件分佈及作用</a></p><p>另外，需要注意 rime 的配置文件严格遵守 yaml 语法，缩进都是两个空格，不能用 tab 代替，否则配置是无效的（很多人折腾死在这）</p><h3 id="候选词个数"><a class="markdownIt-Anchor" href="#候选词个数"></a> 候选词个数</h3><p>修改用户资料夹的 default.custom.yaml ，找到 menu/page_size 字段，如果没有则创建，设置该字段的值即可。例如</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">patch:</span></span><br><span class="line">  <span class="attr">"menu/page_size":</span> <span class="number">8</span></span><br><span class="line">  <span class="attr">schema_list:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">schema:</span> <span class="string">clover</span></span><br></pre></td></tr></table></figure><p>详见 <a href="https://github.com/rime/home/wiki/CustomizationGuide#%E4%B8%80%E4%BE%8B%E5%AE%9A%E8%A3%BD%E6%AF%8F%E9%A0%81%E5%80%99%E9%81%B8%E6%95%B8" target="_blank" rel="noopener">一例、定製每頁候選數</a></p><h3 id="模糊音"><a class="markdownIt-Anchor" href="#模糊音"></a> 模糊音</h3><p>对于模糊音的配置，目前还没有方便的图形界面的配置，如果有需要的话照做吧：</p><p>在用户资料夹创建 clover.custom.yaml ，内容为</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">patch:</span></span><br><span class="line">  <span class="attr">speller/algebra:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 模糊音</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 基础</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">abbrev/^([a-z]).+$/$1/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">abbrev/^([zcs]h).+$/$1/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 补全</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">derive/([dtngkhrzcs])o(u|ng)$/$1o/</span>   <span class="comment"># o = ou; o = ong</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">derive/ong$/on/</span>      <span class="comment"># on = ong</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">derive/^ding$/din/</span>     <span class="comment"># din = ding</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 处理 v 和 u</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">derive/^([nl])ue$/$1ve/</span>   <span class="comment"># nve = nue; lve = lue</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">derive/^([jqxy])u/$1v/</span>    <span class="comment"># v = u; v = u</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 智能纠错</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">derive/ao$/oa/</span>       <span class="comment"># oa = ao</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">derive/([iu])a(o|ng?)$/a$1$2/</span>   <span class="comment"># aio = iao; aing = iang; aung = uang</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">derive/([aeiou])ng$/$1gn/</span>   <span class="comment"># gn = ng</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">derive/un$/uen/</span>    <span class="comment"># uen = un</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">derive/ui$/uei/</span>    <span class="comment"># uei = ui</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">derive/iu$/iou/</span>    <span class="comment"># iou = ui</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">derive/tie$/tei/</span>    <span class="comment"># tei = tie</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">derive/i$/ii/</span>      <span class="comment"># ii = i  # i 不小心按两下</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">derive/u$/uu/</span>      <span class="comment"># ui = u  # u 不小心按两下</span></span><br></pre></td></tr></table></figure><p>然后参考官方推荐的模糊音配置 <a href="https://gist.github.com/lotem/2320943" target="_blank" rel="noopener">https://gist.github.com/lotem/2320943</a></p><p>找到你想添加的模糊音，在第三行前面加上即可。</p><p>再次强调 yaml 的语法，上面每个 derive 前面都是四个空格，不能用 tab 代替。</p><p>如，我想把 en 与 eng 和 in 与 ing 模糊，那么修改后就变成了这样：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">patch:</span></span><br><span class="line">  <span class="attr">speller/algebra:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 模糊音</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">derive/([ei])n$/$1ng/</span>    <span class="comment"># ing = in; eng = en</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">derive/([ei])ng$/$1n/</span>    <span class="comment"># in = ing; en = eng</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 基础</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">abbrev/^([a-z]).+$/$1/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">abbrev/^([zcs]h).+$/$1/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 补全</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">derive/([dtngkhrzcs])o(u|ng)$/$1o/</span>   <span class="comment"># o = ou; o = ong</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">derive/ong$/on/</span>      <span class="comment"># on = ong</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">derive/^ding$/din/</span>     <span class="comment"># din = ding</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 处理 v 和 u</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">derive/^([nl])ue$/$1ve/</span>   <span class="comment"># nve = nue; lve = lue</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">derive/^([jqxy])u/$1v/</span>    <span class="comment"># v = u; v = u</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 智能纠错</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">derive/ao$/oa/</span>       <span class="comment"># oa = ao</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">derive/([iu])a(o|ng?)$/a$1$2/</span>   <span class="comment"># aio = iao; aing = iang; aung = uang</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">derive/([aeiou])ng$/$1gn/</span>   <span class="comment"># gn = ng</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">derive/un$/uen/</span>    <span class="comment"># uen = un</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">derive/ui$/uei/</span>    <span class="comment"># uei = ui</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">derive/iu$/iou/</span>    <span class="comment"># iou = ui</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">derive/tie$/tei/</span>    <span class="comment"># tei = tie</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">derive/i$/ii/</span>      <span class="comment"># ii = i  # i 不小心按两下</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">derive/u$/uu/</span>      <span class="comment"># ui = u  # u 不小心按两下</span></span><br></pre></td></tr></table></figure><p>当然如果你能看懂上面的正则表达式，那么你也可以自己自定义模糊音了。</p><p>修改完成后，记得重新部署生效。</p><h2 id="常见问题"><a class="markdownIt-Anchor" href="#常见问题"></a> 常见问题</h2><h3 id="各种快捷键"><a class="markdownIt-Anchor" href="#各种快捷键"></a> 各种快捷键</h3><p>该方案的默认快捷键为：</p><ul><li>繁简切换Ctrl+Shift+2 或 Ctrl+Shift+f 。</li><li>emoji开关Ctrl+Shift+3</li><li>符号输入Ctrl+Shift+4</li><li>ascii标点切换Ctrl+Shift+5 、 Ctrl+,  或 Ctrl+。</li><li>全半角切换Ctrl+Shift+6 、 Shift+Space</li></ul><p>由于 rime 的设定，这些切换也可以通过打开方案选单来完成，方案选单默认有个快捷键 F4 ，按 F4，再按 2，即可看到这些设定，选择相应的开关设定即可。</p><p>这个快捷键可以修改，详见 <a href="https://github.com/rime/home/wiki/CustomizationGuide#%E4%B8%80%E4%BE%8B%E5%AE%9A%E8%A3%BD%E5%96%9A%E5%87%BA%E6%96%B9%E6%A1%88%E9%81%B8%E5%96%AE%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%8D%B5" target="_blank" rel="noopener">一例、定製喚出方案選單的快捷鍵</a></p><p>如果你不想用 emoji 或者符号输入的功能，则需要修改配置文件才能永久关闭该功能：</p><p>修改 clover.custom.yaml ，添加一个补丁：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">switches:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">zh_simp_s2t</span></span><br><span class="line">    <span class="attr">reset:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">states:</span> <span class="string">[</span> <span class="string">简,</span> <span class="string">繁</span> <span class="string">]</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">emoji_suggestion</span></span><br><span class="line">    <span class="attr">reset:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">states:</span> <span class="string">[</span> <span class="string">"�️️\uFE0E"</span><span class="string">,</span> <span class="string">"�️️\uFE0F"</span> <span class="string">]</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">symbol_support</span></span><br><span class="line">    <span class="attr">reset:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">states:</span> <span class="string">[</span> <span class="string">"无符"</span><span class="string">,</span> <span class="string">"符"</span> <span class="string">]</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ascii_punct</span></span><br><span class="line">    <span class="attr">reset:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">states:</span> <span class="string">[</span> <span class="string">。，,</span> <span class="string">．，</span> <span class="string">]</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">full_shape</span></span><br><span class="line">    <span class="attr">reset:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">states:</span> <span class="string">[</span> <span class="string">半,</span> <span class="string">全</span> <span class="string">]</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ascii_mode</span></span><br><span class="line">    <span class="attr">reset:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">states:</span> <span class="string">[</span> <span class="string">中,</span> <span class="string">英</span> <span class="string">]</span></span><br></pre></td></tr></table></figure><p>将 emoji_suggestion 或 symbol_support 里面的 reset 改成 0 即可。</p><p>这里其实是定制方案选单的选项，reset 表示默认选中 states 的第几个选项，更多请看<a href="https://github.com/rime/home/wiki/CustomizationGuide#%E4%B8%80%E4%BE%8B%E5%AE%9A%E8%A3%BD%E7%B0%A1%E5%8C%96%E5%AD%97%E8%BC%B8%E5%87%BA" target="_blank" rel="noopener">一例、定製簡化字輸出</a></p><h3 id="出现候选框时按-shift-字母不会上屏"><a class="markdownIt-Anchor" href="#出现候选框时按-shift-字母不会上屏"></a> 出现候选框时按 Shift 字母不会上屏</h3><p>由于 rime 的中英文切换的快捷键和 fcitx 的切换输入法的快捷键都是 shift ，fcitx 的快捷键优先于 rime，所以会导致这种情况。</p><p>解决方法：右键托盘图标，配置，打开 fcitx 的配置，点全局配置，额外的激活输入法快捷键，选择禁用。点显示高级选项，在这里的激活输入法可以设置为 shift</p><h3 id="删除一个自造词"><a class="markdownIt-Anchor" href="#删除一个自造词"></a> 删除一个自造词</h3><p>有时候错误的输入了一个词语，这个错误的词语每次会出现在候选框中，看着难过，那么可以删除这个词语。</p><p>按上下键高亮选中这个词语，然后按 Ctrl+Del 或 Shift+Del即可删除该词。（鼠须管的快捷键是 Fn + Shift + Delete）</p><h3 id="词序总是错乱"><a class="markdownIt-Anchor" href="#词序总是错乱"></a> 词序总是错乱</h3><p>有时候，发现以为自己最经常打的字候选词里一定排在第一位，但是时间长了发现好像并不是这么回事，似乎自己最近打的词比使用频率最高的词排序还要靠前，这导致大量的输入错误严重降低了打字效率，后来看到这个帖子</p><p><a href="https://tieba.baidu.com/p/5085900915" target="_blank" rel="noopener">『技术贴』『改进版』小狼毫五笔自动造词、网盘同步</a></p><p>原来 rime 的排序特点就是如此，但是这会导致词序经常很乱，也无法固定首位，怎么办呢，我就这个问题向rime作者反馈，得到的<a href="https://github.com/rime/librime/issues/377#issuecomment-644682195" target="_blank" rel="noopener">回应</a>是，这是记忆力算法，刚开始词序可能会变化较大，长期会趋于稳定，那这么看来暂时先这样用着时间长就好了。</p><h3 id="emoji-字体呈方块状"><a class="markdownIt-Anchor" href="#emoji-字体呈方块状"></a> emoji 字体呈方块状</h3><p>这是因为没有安装 emoji 字体导致。</p><p>在 archlinux 下，可以直接从 aur 安装 apple emoji 的字体：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S ttf-apple-emoji</span><br></pre></td></tr></table></figure><p>在其它 linux 发行版，可以从这个地址下载到 apple emoji 的字体</p><p><a href="https://git.synh.me/dmitry/AUR/-/raw/master/files/ttf-apple-emoji/apple-color-emoji.ttc" target="_blank" rel="noopener">https://git.synh.me/dmitry/AUR/-/raw/master/files/ttf-apple-emoji/apple-color-emoji.ttc</a></p><p>下载好之后，需要复制到 /usr/share/fonts 的某个子目录下，然后更新字体缓存</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/share/fonts</span><br><span class="line">sudo fonts.dir</span><br><span class="line">sudo mkfontdir</span><br></pre></td></tr></table></figure><p>在其它平台，需要自己想办法了。</p><h3 id="导入自定义词库"><a class="markdownIt-Anchor" href="#导入自定义词库"></a> 导入自定义词库</h3><p>可以借助<a href="https://github.com/studyzy/imewlconverter" target="_blank" rel="noopener">深蓝词库转换</a>这个项目，导入它所能支持的所有细胞词库如搜狗拼音细胞词库等。</p><h4 id="基本步骤"><a class="markdownIt-Anchor" href="#基本步骤"></a> 基本步骤</h4><p>首先在用户资料夹下建立 clover.dict.yaml ，内容为</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">clover</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">"1"</span></span><br><span class="line"><span class="attr">sort:</span> <span class="string">by_weight</span></span><br><span class="line"></span><br><span class="line"><span class="attr">import_tables:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">clover.base</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">clover.phrase</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">THUOCL_animal</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">THUOCL_caijing</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">THUOCL_car</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">THUOCL_chengyu</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">THUOCL_diming</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">THUOCL_food</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">THUOCL_IT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">THUOCL_law</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">THUOCL_lishimingren</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">THUOCL_medical</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">THUOCL_poem</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">sogou_new_words</span></span><br></pre></td></tr></table></figure><p>建立了这个文件之后，会覆盖默认的词库。</p><p>关于这个文件的格式详解： <a href="https://github.com/LEOYoon-Tsaw/Rime_collections/blob/master/Rime_description.md#dictyaml-%E8%A9%B3%E8%A7%A3" target="_blank" rel="noopener">Dict.yaml 詳解</a></p><p>在这里，需要说明 import_tables 导入表里的每一项。</p><ul><li><strong>clover.base</strong>   这是单字的字库，包含所有字的拼音、字频，对应文件 clover.base.dict.yaml</li><li><strong>clover.phrase</strong>   这是词组的词库，包含所有基本词汇的拼音、词频，对应文件 clover.phrase.dict.yaml</li><li><strong>THUOCL_</strong>*   这是清华大学开源词库，对应文件 THUOCL_*.dict.yaml</li><li><strong>sogou_new_words</strong>   这是每周更新的搜狗网络流行新词，对应文件 sogou_new_words.dict.yaml</li></ul><p>然后你可以在该文件的后面，按照上述格式（两个空格一个减号一个空格），任意添加你自己创建或导入的词库，当然你也可以删除上述你不想要的词库。</p><p>需要注意以下几点：</p><ul><li><p>clover.base 是不可以删除的，否则会失去所有文字的拼音导致导入任何词库都无效。</p></li><li><p>导入的词库也遵循同样的格式，但是导入的词库的 import_tables 项是无效的（也就是不能嵌套）</p></li><li><p>导入的词库的 name 字段必须和文件名一致，后缀为 .dict.yaml</p><p>例如文件名 “音乐词汇大全.dict.yaml” 的第一行为</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">音乐词汇大全</span></span><br></pre></td></tr></table></figure><p>否则导入的该词库也会无效</p></li></ul><h4 id="例子详解"><a class="markdownIt-Anchor" href="#例子详解"></a> 例子详解</h4><p>下面以导入搜狗音乐词汇大全的细胞词库为例</p><p>首先来这里下载该细胞词库 <a href="https://pinyin.sogou.com/dict/detail/index/15145" target="_blank" rel="noopener">音乐词汇大全</a></p><p>然后用深蓝词库转换为 “音乐词汇大全.txt” ，下面是不同平台的使用方法：</p><ul><li><p>Windows端</p><p>下载地址 <a href="https://github.com/studyzy/imewlconverter/releases/download/v2.8.0/imewlconverter_Windows.zip" target="_blank" rel="noopener">imewlconverter_Windows.zip</a></p><p>打开深蓝词库转换，指定好要转换的文件、源类型为 “搜狗细胞词库scel”，目标类型为 “Rime中州韵”，点击转换，提示是否保存点“是”，保存为 “音乐词汇大全.txt”</p></li><li><p>archlinux</p><p>在 archlinux 下直接从 AUR 安装深蓝词库转换即可 yay -S imewlconverter-bin</p><p>然后执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imewlconverter -i:scel 音乐词汇大全.scel -o:rime 音乐词汇大全.txt</span><br></pre></td></tr></table></figure></li><li><p>其它 linux 发行版</p><p>下载地址 <a href="https://github.com/studyzy/imewlconverter/releases/download/v2.8.0/imewlconverter_Linux_Mac.tar.gz" target="_blank" rel="noopener">imewlconverter_Linux_Mac.tar.gz</a> ，解压得到 ImeWlConverterCmd</p><p>然后执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImeWlConverterCmd -i:scel 音乐词汇大全.scel -o:rime 音乐词汇大全.txt</span><br></pre></td></tr></table></figure></li><li><p>macOS端自测</p></li></ul><p>然后在用户资料夹下创建 “音乐词汇大全.dict.yaml”，内容为</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">音乐词汇大全</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">"1.0"</span></span><br><span class="line"><span class="attr">sort:</span> <span class="string">by_weight</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">阿炳</span><span class="string">a</span> <span class="string">bing</span><span class="number">1</span></span><br><span class="line"><span class="string">阿甲文</span><span class="string">a</span> <span class="string">jia</span> <span class="string">wen</span><span class="number">1</span></span><br><span class="line"><span class="string">阿拉伯风格曲</span><span class="string">a</span> <span class="string">la</span> <span class="string">bo</span> <span class="string">feng</span> <span class="string">ge</span> <span class="string">qu</span><span class="number">1</span></span><br><span class="line"><span class="string">阿勒曼舞曲</span><span class="string">a</span> <span class="string">le</span> <span class="string">man</span> <span class="string">wu</span> <span class="string">qu</span><span class="number">1</span></span><br></pre></td></tr></table></figure><p>把“音乐词汇大全.txt”里面的词都追加到后面。</p><p>然后在用户资料夹下建立 clover.dict.yaml ，内容为</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">clover</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">"1"</span></span><br><span class="line"><span class="attr">sort:</span> <span class="string">by_weight</span></span><br><span class="line"></span><br><span class="line"><span class="attr">import_tables:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">clover.base</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">clover.phrase</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">THUOCL_animal</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">THUOCL_caijing</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">THUOCL_car</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">THUOCL_chengyu</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">THUOCL_diming</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">THUOCL_food</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">THUOCL_IT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">THUOCL_law</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">THUOCL_lishimingren</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">THUOCL_medical</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">THUOCL_poem</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">sogou_new_words</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">音乐词汇大全</span></span><br></pre></td></tr></table></figure><p>右键托盘图标，点击“重新部署”，片刻之后，打字测试看看有没有相应的词汇吧。</p><h3 id="同步词库"><a class="markdownIt-Anchor" href="#同步词库"></a> 同步词库</h3><p>rime 允许不同系统之间进行词库的同步。</p><p>该功能详见 <a href="https://github.com/rime/home/wiki/UserGuide#%E5%90%8C%E6%AD%A5%E7%94%A8%E6%88%B6%E8%B3%87%E6%96%99" target="_blank" rel="noopener">同步用戶資料</a></p><p>默认同步的文件夹在用户资料夹下 sync ，点击同步时，会生成这个文件夹，你也可以设置 installation.yaml 里面的 sync_dir 来修改同步文件夹。</p><p>用户词库词频信息被保存在 同步文件夹下的对应 id 里的 clover.userdb.txt 里，每次点击同步时，会合并所有 id 里的该文件。</p><p>所以可以利用云同步服务例如 <a href="https://www.jianguoyun.com/" target="_blank" rel="noopener">坚果云</a> 一类的软件，来实现个人不同电脑之间的词库同步。</p><h3 id="其它"><a class="markdownIt-Anchor" href="#其它"></a> 其它</h3><p>其它常见问题看<a href="https://github.com/rime/home/wiki/CustomizationGuide#diy-%E8%99%95%E6%96%B9%E9%9B%86" target="_blank" rel="noopener">官方文档的常见问题</a>吧。</p><h2 id="构建"><a class="markdownIt-Anchor" href="#构建"></a> 构建</h2><p>一般情况下，我在发布页提供的是已经生成好的词库和部署好的二进制文件，直接使用即可。</p><p>如果你想自己从零开始构建，或者想为别的 linux 发行版打包，那么继续往下看。</p><p>该仓库的内容只包含构建四叶草输入法方案的脚本，构建需要以下环境</p><p>操作系统： linux</p><p>python版本： 3</p><p>python依赖的库： <a href="https://github.com/fxsjy/jieba" target="_blank" rel="noopener">jieba</a>、<a href="https://github.com/mozillazg/python-pinyin" target="_blank" rel="noopener">pypinyin</a>、<a href="https://github.com/BYVoid/OpenCC" target="_blank" rel="noopener">opencc</a>、requests</p><p>下载工具（三者任意一个均可）： <a href="http://aria2.sourceforge.net/" target="_blank" rel="noopener">aria2</a>、<a href="https://www.gnu.org/software/wget/wget.html" target="_blank" rel="noopener">wget</a>、<a href="https://curl.haxx.se/" target="_blank" rel="noopener">curl</a></p><p>解压工具（三者任意一个均可）： <a href="https://www.info-zip.org/UnZip.html" target="_blank" rel="noopener">unzip</a>、<a href="https://libarchive.org/" target="_blank" rel="noopener">bsdtar</a>、<a href="http://p7zip.sourceforge.net/" target="_blank" rel="noopener">7z</a></p><p>rime基础库： <a href="https://github.com/rime/librime" target="_blank" rel="noopener">librime</a></p><p>克隆此仓库，然后直接执行构建即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build</span><br></pre></td></tr></table></figure><p>完成后，会生成 cache 目录和 data 目录</p><ul><li>data 是最终生成的目录</li><li>cache 是生成过程中下载和生成的中间文件</li></ul><p>其中，执行 build 时，可以有个参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build [minfreq]</span><br></pre></td></tr></table></figure><p>minfreq 代表360万词里面指定的最小词频，频率低于该值的词语会被筛选掉，达到精简词库的目的，默认是100，该值越小，最终生成的词库越大，为 0 表示不精简词库（会生成大约 100 兆左右的词库）。</p><p>构建完成后，可以打包，在 data 目录生成发布用的压缩包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;pack [ver]</span><br></pre></td></tr></table></figure><p>ver 表示版本号，例如 1.1.2</p><hr /><h2 id="写在最后"><a class="markdownIt-Anchor" href="#写在最后"></a> 写在最后</h2><p>此项目完全开源，你可以随意 fork 或修改和定制，如果你觉得好用，可以来<a href="https://aur.archlinux.org/packages/rime-cloverpinyin/" target="_blank" rel="noopener">AUR投票</a>和在<a href="https://github.com/fkxxyz/rime-cloverpinyin" target="_blank" rel="noopener">github上star</a>，投票和star的人越多越容易被搜索到，以此更好地传播出去。</p><p>再次重复开头说的：</p><p><strong>这个项目我会持续更新，因为我一直在用输入法，我会调教到完全合我的口味习惯为止（我过去一直在用搜狗拼音输入法）。所以如果你觉得哪里不好用，或者哪里想改善，一定要及时在 <a href="https://github.com/fkxxyz/rime-cloverpinyin/issues" target="_blank" rel="noopener">issues</a> 提出，我只要看到就会回复。</strong></p><p>当然你也可以直接<a href="https://www.fkxxyz.com/about/#%E5%85%B3%E4%BA%8E%E6%88%91" target="_blank" rel="noopener">联系我</a>本人。</p>]]></content>
      
      
      <categories>
          
          <category> 原创开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rime </tag>
            
            <tag> fcitx </tag>
            
            <tag> 输入法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 python 实现了个文本简谱解释器，可以用来编配和弦</title>
      <link href="/d/simp-score/"/>
      <url>/d/simp-score/</url>
      
        <content type="html"><![CDATA[<p>最近学了一点即兴伴奏，想训练自己分辨和弦，编配和弦的能力，但是手头没有钢琴去尝试，只有光遇游戏里的十五键钢琴（惨奥）。</p><p>无意之中发现了这么个项目 <a href="https://github.com/Rainbow-Dreamer/musicpy/" target="_blank" rel="noopener">https://github.com/Rainbow-Dreamer/musicpy/</a></p><p>顿时来了灵感，这么熟练python了，为什么不用python来写音乐呢</p><a id="more"></a><h2 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h2><p>该项目作者的思想是用代码来写音乐，达到一定的抽象程度，短短几十几百个字节能够表达出一个midi文件轨道记录的几千个音符。</p><p>我所了解到的即兴伴奏的思想就是左手基本上就是几个套路（如隔三空二四二之类的），而用midi文件来表达这些的话，却要把每个音符全都无脑的记录下来。</p><p>其实呢，只需要主旋律，和这个小节对应的和弦，再加上伴奏的织体，就足以表达了。</p><p>那么我可不可以开发这样一个项目呢，能够随意改动和弦和织体，然后不断的试听和感受不同和弦不同织体产生的效果，达到很好的训练目的（而这一需求，要是用一些专业软件不断的调整音轨里面的高度来实现，将是灾难性的麻烦），我希望我改个和弦只需要改一个字母！！</p><h2 id="程序逻辑设计"><a class="markdownIt-Anchor" href="#程序逻辑设计"></a> 程序逻辑设计</h2><p>最终决定，用文本格式表达简谱的内容，包含主旋律、和弦、织体等信息，自己定义其格式，然后编写一个简谱解释器，能够播放出来或者转换成音轨记录到 midi 文件里面。</p><p>初步的规则如下</p><ol><li>用 1～7 表达简谱中的音符，0 代表休止符，和简谱一致</li><li>在一个音符后面，用 ` 代表高音，用 . 代表低音，可以叠加</li><li>在一个音符后面，用 _ 代表八分音符（可叠加成十六分音符等），用 - 代表延音，用 ^ 表示连音线，用 * 表示附点</li><li>在一个音符后面，用 b 代表降音，用 # 代表升音</li><li>用中括号 [] 括起来的音符表示同时发音</li><li>用括号 () 括起来的音符，可以同时进行 `._b#的运算，降低表达长度</li><li>在小括号后面加 $ 表示括号内全部连音，比如 (222)$ 表示一个四分音符内三连音</li><li>用 | 表示小节线，每一行可以放任意多小节，换行表示两个小节叠加成不同的声部，用单独的一减号 - 表示另起一个小节，而不是叠加声部。</li><li>能够按特定的格式提前定义若干个织体格式，然后将织体当成一个函数，参数是和弦，程序自动计算出织体加和弦对应的若干个音符，进而得到整个伴奏。</li></ol><p>织体究竟该怎么定义，这是个头大的问题，因为实际应用中，可以很灵活应用，比如我可以隔三空二四，可以隔三空二四二，还可以减法法则，从后往前减去若干个音符。</p><p>最终决定用替换法，比如 C 大调和弦 C E G，我用 1 表示 C，2 表示 E，3表示 5，4表示高音C，5表示高音E，以此类推。那么我隔三空二就可以表示为 1343，隔三空二四二是 13435343，隔三永远是 13，那么我可以把13用一个字母代替，比如a，把43和53分别用 b和c表示，那隔三空二四二就表示为 abcb，隔三空二二二就可以是 abbb，哈哈哈哈哈哈哈。</p><p>精心设计之后，决定织体定义格式如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">texture &lt;织体名&gt;: &#123;</span><br><span class="line">@ &#x3D; &lt;默认的织体标识&gt;   # 可选，&lt;默认的织体标识&gt; 可以是下面等号左边的任意一个值，表示默认值。</span><br><span class="line">&lt;织体标识1&gt; &#x3D; &lt;织体内容1&gt;</span><br><span class="line">&lt;织体标识2&gt; &#x3D; &lt;织体内容2&gt;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>织体标识就相当于上面讲到的 a b c ，织体内容就是上面讲到的 13435343。</p><p>实际解析时，会先将若干个织体标识组转换为织体内容，然后织体内容最终会被转换成具体的音符。</p><p>下面举例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">texture s:&#123;</span><br><span class="line">@ &#x3D; 1</span><br><span class="line">1 &#x3D; (13434343).._</span><br><span class="line">a &#x3D; (13).._</span><br><span class="line">b &#x3D; (43).._</span><br><span class="line">c &#x3D; (53).._</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一定义，再定义如何调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">织体名(和弦[,织体标识组][,和弦转位][,减法法则])</span><br></pre></td></tr></table></figure><p>国际惯例，中括号是可选参数</p><p>那么， s(C,abcb) 替换里面的标识就等价于 (13)…_(43)…_(53)…_ 进而等价于 (15)…_(1`5)…_(3`5)…_(1`5)…_</p><p>也就是说 s(C,abcb) 就表示 C 和弦的隔三空二四二，只需要改一个字母把 C 改成 F，就成了四级和弦的隔三空二四二！</p><p>下面介绍各个参数</p><ol><li>织体标识组省略：省略的情况下，默认是 @ 指向的织体。</li><li>和弦转位：用 +1 或 +2 等等表示，+1 表示第一转位，即 s(C,+1) 最终会被解析成(31`)…_(`3`1)…_(3`1`)…_(3`1`)…_</li><li>减法法则：用 -1 或 -3 等等表示，表示减去多少个音符，即 s(C,-1) 最终会被解析成 (15)…_(1`5)…_(1`5)…_(1`0)…_</li></ol><p>三个参数位置可以随意调整和缺省，因为解析的时候，前面带有+就是和弦转位，-就是减法法则，不带就是织体标识，参数之间用逗号隔开。</p><p>此外还有一些细节，在示例中说到，详见 <a href="https://github.com/fkxxyz/simp-score/blob/master/summer.txt" target="_blank" rel="noopener">summer.txt</a>。</p><h2 id="程序诞生"><a class="markdownIt-Anchor" href="#程序诞生"></a> 程序诞生</h2><p>经过几天的调试努力，最终诞生，取名为 <a href="https://github.com/fkxxyz/simp-score" target="_blank" rel="noopener">simp-score</a>，用法参数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">simp-score &lt;src&gt; [dest]</span><br></pre></td></tr></table></figure><p>表示将 src 文件里记录的简谱，解析并输出到 dest 的 midi 文件中。</p><p>还有一些可选参数，详见 --help</p><p>我将菊次郎的夏天作为示例乐谱 summer.txt，最终生成 summer.mid</p><p>注意我调用了 mingus 库的内容，需要 pip install mingus 安装这个库，才能正常运行。</p><h2 id="后序可能的改进"><a class="markdownIt-Anchor" href="#后序可能的改进"></a> 后序可能的改进</h2><p>如果后序改进，可能会添加自定义和弦的功能，预设了大多和弦在程序开头，或许万一有别的特殊需要呢。</p>]]></content>
      
      
      <categories>
          
          <category> 原创开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 音乐 </tag>
            
            <tag> 和弦 </tag>
            
            <tag> 即兴伴奏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fcitx 真的也可以这么美 —— 对 fcitx 使用搜狗皮肤的改进</title>
      <link href="/d/ssfconv/"/>
      <url>/d/ssfconv/</url>
      
        <content type="html"><![CDATA[<p>fcitx输入法框架能够自定义皮肤，然后有个很nb的作者开发了个搜狗皮肤转换成fcitx皮肤的，这是原项目地址https://github.com/VOID001/ssf2fcitx</p><p>然后我亲自试了几个我喜欢的皮肤，居然真的可以转换，跟搜狗差不多了，不过一段时间后，发现一些bug：设置了皮肤之后，输入法菜单隔空而且透明，字都看不清。部分皮肤文字位置很奇怪。于是，我看了他的源码，发现逻辑还挺简单，然后看了下fcitx的自定义皮肤的各种格式，打算亲自研究研究这是怎么回事。</p><p>最终打算参考这个项目，自己用python写个，不仅解决了zip压缩格式，还实现了图片自动裁剪（不愧是胶水语言）</p><p><img src="/img/ssfskin-5.png" alt="" /></p><a id="more"></a><p>最终两个函数实现，取名为转换器ssfconv，放到 github 托管 <a href="https://github.com/fkxxyz/ssfconv" target="_blank" rel="noopener">https://github.com/fkxxyz/ssfconv</a></p><p>在原作者的基础上进行了下面几方面改进：</p><ol><li>部分皮肤文字位置重新计算，摆放更合理</li><li>将菜单的背景也设置成皮肤的主题色，文字大小和颜色均计算到合理</li><li>字体单位改成像素，和搜狗一致，完美还原</li><li>调整了翻页指示器的位置，自动生成指示器的图像</li></ol><p>直接上图吧（我自己都没想到linux的输入法也可以这么美）</p><p><img src="/img/ssfskin-1.png" alt="" /></p><p><img src="/img/ssfskin-2.png" alt="" /></p><p><img src="/img/ssfskin-3.png" alt="" /></p><p><img src="/img/ssfskin-4.png" alt="" /></p><p><img src="/img/ssfskin-6.png" alt="" /></p><p><img src="/img/ssfskin-7.png" alt="" /></p><h2 id="开始使用"><a class="markdownIt-Anchor" href="#开始使用"></a> 开始使用</h2><p>下面直接举例吧。</p><h3 id="下载此仓库"><a class="markdownIt-Anchor" href="#下载此仓库"></a> 下载此仓库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/fkxxyz/ssfconv.git</span><br><span class="line">cd ssfconv</span><br></pre></td></tr></table></figure><h3 id="下载皮肤"><a class="markdownIt-Anchor" href="#下载皮肤"></a> 下载皮肤</h3><p>先从<a href="https://pinyin.sogou.com/skins/" target="_blank" rel="noopener">搜狗输入法的皮肤官网</a>下载自己喜欢的皮肤，得到ssf格式的文件，例如 【雨欣】蒲公英的思念.ssf</p><h3 id="转换皮肤"><a class="markdownIt-Anchor" href="#转换皮肤"></a> 转换皮肤</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ssfconv  【雨欣】蒲公英的思念.ssf  【雨欣】蒲公英的思念</span><br></pre></td></tr></table></figure><h3 id="复制到用户皮肤目录"><a class="markdownIt-Anchor" href="#复制到用户皮肤目录"></a> 复制到用户皮肤目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/.config/fcitx/skin/</span><br><span class="line">cp  【雨欣】蒲公英的思念  ~/.config/fcitx/skin/</span><br></pre></td></tr></table></figure><h3 id="使用该皮肤"><a class="markdownIt-Anchor" href="#使用该皮肤"></a> 使用该皮肤</h3><p>右键输入法托盘图表，选中皮肤，这款皮肤是不是出现在列表里了呢，尽情享用吧。</p><h2 id="详细介绍"><a class="markdownIt-Anchor" href="#详细介绍"></a> 详细介绍</h2><p>使用方法被封装得非常简单，像个转换器，可以在下面四种格式之间任意转换：</p><ol><li>ssf格式（加密）</li><li>ssf格式（未加密，本质是zip）</li><li>文件夹（解密或解压ssf格式得到）</li><li>fcitx格式（在文件夹的基础上多了fcitx_skin.conf，可用于fcitx）</li></ol><p>命令行参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssfconv &lt;src&gt; &lt;dest&gt; [-t type]</span><br></pre></td></tr></table></figure><p>源文件和目标文件是必选参数，转换的目标类型 -t 是可选参数，type值是下面四个值之一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fcitx可直接用于fcitx的文件夹</span><br><span class="line">dir解包后的文件夹</span><br><span class="line">encrypted加密的ssf皮肤</span><br><span class="line">zip未加密的ssf皮肤（zip）</span><br></pre></td></tr></table></figure><p>默认是转换为 fcitx 格式。</p><p>注意，源文件的格式可以是以上任意四个格式之一，不需要指定，程序已经可以智能识别格式。</p><h2 id="已知缺陷"><a class="markdownIt-Anchor" href="#已知缺陷"></a> 已知缺陷</h2><p>因为fcitx的限制，输入框里只能对文字的外边距进行设置，无法像搜狗拼音输入法一样任意调整坐标，导致部分皮肤只能在图片拉升和文件位置靠右来二选一的取舍。不过大多数皮肤都能挺不错的转换，只有少数皮肤实在是没办法了，只好用图片拉升代替（原作者是将文字调整到靠右，留了很多空白）。</p>]]></content>
      
      
      <categories>
          
          <category> 原创开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fcitx </tag>
            
            <tag> 输入法 </tag>
            
            <tag> 皮肤 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探索在 Archlinux 下使用 wine 时偶尔提示未找到 wine-mono 的完美解决方案</title>
      <link href="/learn/wine-mono/"/>
      <url>/learn/wine-mono/</url>
      
        <content type="html"><![CDATA[<p>使用 archlinux 有一段日子了，发现有时候在使用 wine 的过程中，明明已经装了 wine-mono 这个包，但依然时常出现这个对话框，很恼火，是时候把这问题探究彻底了。</p><p><img src="/img/no-mono.png" alt="no-mono" /></p><a id="more"></a><h2 id="问题描述"><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h2><p>我们知道，wine 的 mono <a href="http://xn--5nqz97cmmr.NET" target="_blank" rel="noopener">组件是.NET</a> Framework的开源和跨平台实现，能够让 Wine 顺利运行很多 .NET应用程序。</p><p>出现上述对话框后，点击安装，虽然会自动从 wine 官网把 mono 组件下到 $WINEPREFIX 里面，也是可以用，但是下的很慢，耗费很多时间，而且用 .NET 程序用的少，有时候仅仅想测试一个 exe 程序，点取消的话，每次要 wine 一个程序的时候都会弹出这个，实在讨厌。</p><p>后来，我觉得最新版的 wine 没有 wine-stable 稳定，我自己从 aur 编译了 wine-stable 之后，开始次次出现以上对话框了，经过百度谷歌，搜到的全是解决别的问题，无奈之下只能自己动手丰衣足食。</p><h2 id="问题探究"><a class="markdownIt-Anchor" href="#问题探究"></a> 问题探究</h2><p>先看看 wine-mono 这个包包含什么。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -Ql wine-mono</span><br></pre></td></tr></table></figure><p>根据输出结果看出，原来只包含一个文件，还带版本号 /usr/share/wine/mono/wine-mono-4.9.3.msi</p><p>emmmm，什么？带版本号？我想起这问题偶然出现，什么时候出现呢，就是升级系统的时候会偶尔出现。那么 wine 是如何找到这个文件，以确认 mono 存在性呢？难道是扫描 /usr/share/wine/mono/ 整个目录？那可以找到的啊。</p><p>根据这些线索，我猜测，wine 是根据绝对路径和带版本号的文件名寻找 mono 的，一旦所需要的 mono 版本，和系统中存在的 mono 版本不一样，就会出现那找不到的对话框。</p><p>如何验证这个猜想呢，我想到 grep -rn 这个在所有子目录里面查找匹配的功能，开始行动。</p><p>先查看 wine-stable 包含哪些文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -Ql wine-stable</span><br></pre></td></tr></table></figure><p>根据输出结果，大概知道 wine 的文件集中在以下几个目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;lib&#x2F;wine</span><br><span class="line">&#x2F;usr&#x2F;lib32&#x2F;wine</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;wine</span><br></pre></td></tr></table></figure><p>还有很多细小的目录，直接搜会很麻烦。我想到一个方案，把以前编译好的 wine-stable 安装包解压到一个目录里面，集中搜索。说干就干！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir /tmp/wine</span><br><span class="line">cd /tmp/wine</span><br><span class="line">tar xf ~/.cache/yay/wine-stable/wine-stable-4.0.2-1-x86_64.pkg.tar.xz</span><br><span class="line">ls</span><br></pre></td></tr></table></figure><p>然后开始搜索</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -rn wine-mono</span><br></pre></td></tr></table></figure><p>几秒钟后，输出结果只有三行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">匹配到二进制文件 usr&#x2F;lib32&#x2F;wine&#x2F;appwiz.cpl.so</span><br><span class="line">匹配到二进制文件 usr&#x2F;lib&#x2F;wine&#x2F;appwiz.cpl.so</span><br><span class="line">.BUILDINFO:1138:installed &#x3D; wine-mono-4.9.2-1-any</span><br></pre></td></tr></table></figure><p>最后一行保存的是软件包的信息，wine 启动的过程中肯定是不会用的。那…重点研究下 usr/lib/wine/appwiz.cpl.so 这个文件好了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -a wine-mono usr/lib/wine/appwiz.cpl.so</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.47wine_gecko-2.47-x86_64.msigeckoMSHTMLGeckoUrlGeckoCabDir4.7.5wine-mono-4.7.5.msimonoDotnetMonoUrlMonoCabDir%s does not exist and could not be created: %s</span><br></pre></td></tr></table></figure><p>果然，包含了字符串 wine-mono-4.7.5.msi，也就是说，wine-stable 是依赖于 4.7.5 版本 wine-mono，而我系统里存在的是 wine-mono-4.9.3.msi，找不到很正常。</p><p>好的，现在做个实验，把 wine-mono-4.9.3.msi 复制为 wine-mono-4.7.5.msi，问题是不是解决了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/share/wine/mono</span><br><span class="line">mv wine-mono-4.9.3.msi wine-mono-4.7.5.msi</span><br><span class="line">rm -rf ~/.wine</span><br><span class="line">winecfg</span><br></pre></td></tr></table></figure><p>发现，确实没再弹出那个对话框了，猜想成立！</p><p>终于找到原因了，接下来想想怎么完美解决这个问题吧。</p><h2 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案</h2><p>我想到几个方案来解决这个问题：</p><ol><li>安装旧版本的 wine-mono 的包。</li><li>更新 wine 到最新版本，确保所需的 mono 版本与官方仓库最新的 mono 的版本一致。</li><li>对 <a href="http://appwiz.cpl.so" target="_blank" rel="noopener">appwiz.cpl.so</a> 这个文件进行二进制编辑，修改里面的版本号字符串。</li><li>把系统里的 wine-mono-4.9.3.msi 重命名 wine-mono-4.7.5.msi</li><li>创建符号链接解决这个问题。</li></ol><p>想出了这么多办法，逐一分析这些办法的利弊：</p><ol><li><strong>安装旧版本的 wine-mono 包</strong>：这需要降级软件包，需要用 downgrade，然后可以把 wine-mono 这个软件包设为忽略更新的包写到 pacman.conf 里，这样做的话，每次升级 wine-stable 都需要检查版本号手动装合适的 wine-mono，有些麻烦。</li><li><strong>更新 wine 到最新版本</strong>：我大量实践过程中，感觉 wine-stable 确实要稳定一些，最新版的虽然有新特性但是免不了很多 bug。而且，就算更新到最新，也会偶尔出现版本不匹配的问题。</li><li><strong>对 <a href="http://appwiz.cpl.so" target="_blank" rel="noopener">appwiz.cpl.so</a> 这个文件进行二进制编辑</strong>：这个操作很骚，但是万一以后版本号长度不一样了，怎么办呢，而且每次更新都得改也很麻烦。</li><li><strong>重命名系统里的 wine-mono</strong>：这个操作会影响到系统里包含的文件，而每次升级之后，旧的 wine-mono 文件就不会被删掉，然后装上了新的，白白占用空间，每次来处理，也很麻烦。</li><li><strong>创建符号链接</strong>：创建符号链接，可谓是 linux 解决这类问题最妙的办法，直接将 wine-mono-4.9.3.msi 链接到 wine-mono-4.7.5.msi，非常方便，但是每次更新还是要过来处理，还是很麻烦。</li></ol><p>可见创建符号链接是目前最低成本的解决方法，那，有没有完美的解决方法呢？</p><h2 id="完美解决已失效"><a class="markdownIt-Anchor" href="#完美解决已失效"></a> 完美解决（已失效）</h2><p>通过以上思考，我最需要的就是，更新后不需要手动去创建符号链接，用脚本自动实现更新后的解决版本不一致的问题。</p><p>每次更新后，更新什么？更新 wine-stable 或 wine-mono 的时候。</p><p>如何在每次更新这两个包，触发调用脚本呢？利用包管理器的 <a href="https://wiki.archlinux.org/index.php/Pacman_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#Hooks" target="_blank" rel="noopener">hook</a> 功能。</p><p>看来完美的解决方案是存在的，下面来列出，需要解决的几个子问题：</p><ol><li>脚本如何读取 <a href="http://appwiz.cpl.so" target="_blank" rel="noopener">appwiz.cpl.so</a> 这个文件来获取所需的版本号呢？</li><li>脚本如何确定当前系统存在的 wine-mono 的版本号对应的文件呢？</li><li>升级后旧版本留下的符号链接会多余存在很多垃圾要怎么办呢？</li></ol><p>然后这些问题逐一得到解决：</p><ol><li><p>直接利用正则表达式匹配</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n 's/.*\(wine-mono-[[:digit:].]\+.msi\).*/\1/p' /usr/lib/wine/appwiz.cpl.so</span><br></pre></td></tr></table></figure><p>输出结果为 wine-mono-4.7.5.msi</p></li><li><p>直接用包管理器查询包含的文件，然后正则匹配到具体文件名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -Qlq wine-mono | grep -o 'wine-mono-\([[:digit:].]\+\).msi'</span><br></pre></td></tr></table></figure><p>输出结果为 wine-mono-4.9.3.msi</p></li><li><p>每次更新后，先将 /usr/share/wine/mono 里的符号链接全删了，再建立即可。</p></li></ol><p>将以上思路进行具体实施，写成 <a href="https://wiki.archlinux.org/index.php/Pacman_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#Hooks" target="_blank" rel="noopener">hook</a> 脚本，得到完美解决。具体 hook 的写法参见 <a href="https://jlk.fjfi.cvut.cz/arch/manpages/man/alpm-hooks.5" target="_blank" rel="noopener">alpm-hooks文档</a> 。</p><p>在 /etc/pacman.d/hooks 里面新建一个文件 wine-mono-version-fix.hook</p><p>里面写入</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Trigger]</span></span><br><span class="line"><span class="attr">Type</span> = File</span><br><span class="line"><span class="attr">Operation</span> = Install</span><br><span class="line"><span class="attr">Operation</span> = Upgrade</span><br><span class="line"><span class="attr">Target</span> = usr/lib/wine/appwiz.cpl.so</span><br><span class="line"><span class="attr">Target</span> = usr/share/wine/mo<span class="literal">no</span>/*</span><br><span class="line"></span><br><span class="line"><span class="section">[Action]</span></span><br><span class="line"><span class="attr">Description</span> = Fixing the version of wine-mo<span class="literal">no</span> file.</span><br><span class="line"><span class="attr">When</span> = PostTransaction</span><br><span class="line"><span class="attr">Exec</span> = /usr/bin/sh -c <span class="string">'find /usr/share/wine/mono -type l -exec unlink &#123;&#125; \; ; ln -sf "$(pacman -Qlq wine-mono | grep "wine-mono-\\([[:digit:].]\\+\\).msi")" "/usr/share/wine/mono/$(sed -n "s/.*\\(wine-mono-[[:digit:].]\\+.msi\\).*/\\1/p" /usr/lib/wine/appwiz.cpl.so)" 2&gt;/dev/null ; true'</span></span><br></pre></td></tr></table></figure><p>至此，完美解决，以后无论如何更新 wine 或 wine-mono，或者无论如何更换 wine 的版本，总是能找到对应的 wine-mono，也再也不会弹出那个对话框了。</p><p>后来发现 wine-gecko 也出了类似的情况，那么同理。</p><p>在 /etc/pacman.d/hooks 里面新建一个文件 wine-gecko-version-fix.hook</p><p>里面写入</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Trigger]</span></span><br><span class="line"><span class="attr">Type</span> = File</span><br><span class="line"><span class="attr">Operation</span> = Install</span><br><span class="line"><span class="attr">Operation</span> = Upgrade</span><br><span class="line"><span class="attr">Target</span> = usr/lib/wine/appwiz.cpl.so</span><br><span class="line"><span class="attr">Target</span> = usr/share/wine/gecko/*</span><br><span class="line"></span><br><span class="line"><span class="section">[Action]</span></span><br><span class="line"><span class="attr">Description</span> = Fixing the version of wine-gecko file.</span><br><span class="line"><span class="attr">When</span> = PostTransaction</span><br><span class="line"><span class="attr">Exec</span> = /usr/bin/sh -c <span class="string">'find /usr/share/wine/gecko -type l -exec unlink &#123;&#125; \; ; ln -sf "$(pacman -Qlq wine-gecko | grep "wine.gecko-\\([-.[:digit:]]\\+\\)-x86_64.msi")" "/usr/share/wine/gecko/$(sed -n "s/.*\\(wine.gecko-[-.[:digit:]]\+-x86_64.msi\\).*/\\1/p" /usr/lib/wine/appwiz.cpl.so)" 2&gt;/dev/null ; ln -sf "$(pacman -Qlq wine-gecko | grep "wine.gecko-\\([-.[:digit:]]\\+\\)-x86.msi")" "/usr/share/wine/gecko/$(sed -n "s/.*\\(wine.gecko-[-.[:digit:]]\+-x86.msi\\).*/\\1/p" /usr/lib32/wine/appwiz.cpl.so)" 2&gt;/dev/null ; true'</span></span><br></pre></td></tr></table></figure><h2 id="后续完美解决"><a class="markdownIt-Anchor" href="#后续完美解决"></a> 后续完美解决</h2><p>上述方法成功维持了一段时间，但最近发现又蹦出那个对话框，上述方法失效了？经过探索发现，/usr/lib/wine/appwiz.cpl.so 这个文件已经被改动，里面的相关字符串已经成了 unicode 字符串，并且文件名多了个 -x86，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wine-mono-5.0.0-x86.msi</span><br></pre></td></tr></table></figure><p>那么，根据这种情况改进一下即可解决。</p><ol><li><p>利用正则表达式匹配</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings -eb /usr/lib/wine/appwiz.cpl.so | sed -n 's/.*\(wine-mono-[-x[:digit:].]\+.msi\).*/\1/p'</span><br></pre></td></tr></table></figure><p>输出结果为 wine-mono-5.0.0-x86.msi</p></li><li><p>用包管理器查询包含的文件，然后正则匹配到具体文件名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -Qlq wine-mono | grep -o 'wine-mono-\([-x[:digit:].]\+\).msi'</span><br></pre></td></tr></table></figure><p>输出结果为 wine-mono-5.0.0.msi</p></li></ol><p>写成 hook 脚本 wine-mono-version-fix.hook</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Trigger]</span></span><br><span class="line"><span class="attr">Type</span> = File</span><br><span class="line"><span class="attr">Operation</span> = Install</span><br><span class="line"><span class="attr">Operation</span> = Upgrade</span><br><span class="line"><span class="attr">Target</span> = usr/lib/wine/appwiz.cpl.so</span><br><span class="line"><span class="attr">Target</span> = usr/share/wine/mo<span class="literal">no</span>/*</span><br><span class="line"></span><br><span class="line"><span class="section">[Action]</span></span><br><span class="line"><span class="attr">Description</span> = Fixing the version of wine-mo<span class="literal">no</span> file.</span><br><span class="line"><span class="attr">When</span> = PostTransaction</span><br><span class="line"><span class="attr">Exec</span> = /usr/bin/sh -c <span class="string">'find /usr/share/wine/mono -type l -exec unlink &#123;&#125; \; ; ln -sf "$(pacman -Qlq wine-mono | grep "wine-mono-\\([-x[:digit:].]\\+\\).msi")" "/usr/share/wine/mono/$(strings -eb /usr/lib/wine/appwiz.cpl.so | sed -n "s/.*\\(wine-mono-[-x[:digit:].]\\+.msi\\).*/\\1/p")" 2&gt;/dev/null ; true'</span></span><br></pre></td></tr></table></figure><p>同理，gecko 也这样解决。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Trigger]</span></span><br><span class="line"><span class="attr">Type</span> = File</span><br><span class="line"><span class="attr">Operation</span> = Install</span><br><span class="line"><span class="attr">Operation</span> = Upgrade</span><br><span class="line"><span class="attr">Target</span> = usr/lib/wine/appwiz.cpl.so</span><br><span class="line"><span class="attr">Target</span> = usr/share/wine/gecko/*</span><br><span class="line"></span><br><span class="line"><span class="section">[Action]</span></span><br><span class="line"><span class="attr">Description</span> = Fixing the version of wine-gecko file.</span><br><span class="line"><span class="attr">When</span> = PostTransaction</span><br><span class="line"><span class="attr">Exec</span> = /usr/bin/sh -c <span class="string">'find /usr/share/wine/gecko -type l -exec unlink &#123;&#125; \; ; ln -sf "$(pacman -Qlq wine-gecko | grep "wine.gecko-\\([-.[:digit:]]\\+\\)-x86_64.msi")" "/usr/share/wine/gecko/$(strings -eb /usr/lib/wine/appwiz.cpl.so | sed -n "s/.*\\(wine.gecko-[-.[:digit:]]\+-x86_64.msi\\).*/\\1/p")" 2&gt;/dev/null ; ln -sf "$(pacman -Qlq wine-gecko | grep "wine.gecko-\\([-.[:digit:]]\\+\\)-x86.msi")" "/usr/share/wine/gecko/$(strings -eb /usr/lib32/wine/appwiz.cpl.so | sed -n "s/.*\\(wine.gecko-[-.[:digit:]]\+-x86.msi\\).*/\\1/p")" 2&gt;/dev/null ; true'</span></span><br></pre></td></tr></table></figure><p>最后，我将上述两个文件用 PKDBUILD 打包上传到 AUR，方便后续使用，包名为 <a href="https://aur.archlinux.org/packages/wine-mono-gecko-version-fix/" target="_blank" rel="noopener">wine-mono-gecko-version-fix</a></p>]]></content>
      
      
      <categories>
          
          <category> 探究学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> archlinux </tag>
            
            <tag> wine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>猜猜我最终选择了什么桌面环境</title>
      <link href="/c/myde/"/>
      <url>/c/myde/</url>
      
        <content type="html"><![CDATA[<p>接触archlinux也有两年多了，桌面环境到底应该选哪个，我也纠结过这个问题，而且桌面环境各有各的优点。</p><p>gnome和kde虽然完善但过于庞大，性能不好时常卡顿。deepin的桌面环境虽然漂亮但是bug多时常也假死，lxde、lxqt这些轻量桌面环境虽然小巧但是界面美观性堪忧，xfce4美观比不上庞大桌面环境，性能不如lxde都不占优，用平铺式的如i3、dwm等也不太容易适应，还有fvwm？那配置复杂度了根本没时间搞那玩意好嘛。桌面环境的选择简直难上加难啊，哈哈。</p><a id="more"></a><p><img src="/img/myde.png" alt="" /></p><h2 id="我的探索历程"><a class="markdownIt-Anchor" href="#我的探索历程"></a> 我的探索历程</h2><h3 id="体验各个桌面环境"><a class="markdownIt-Anchor" href="#体验各个桌面环境"></a> 体验各个桌面环境</h3><p>由于包的数量众多，要实验各个软件，就会留下很多包，尤其是桌面环境涉及到的包更多依赖更复杂，很难找到这些包名，卸载的话会漏很多，强迫症的我不想留一些不必要的软件，一开始比较蠢，把每次装了什么都记录下来，然后之后要卸载的时候，一条一条的 pacman -Rsc 。由于有着重复的工作都能用编程代替的思想，就开始思考，为何不自己编个脚本来代替这个重复的过程呢？我能不能把我需要的软件记录到一起，然后脚本自动为我卸载不必要的包呢？</p><p>于是，一个伟大的白名单列表机制管理软件包的脚本诞生了。<a href="/d/spacman/">详见spacman</a></p><p>只需要手动记录一下我所有需要的顶层包到一个文本文档，然后脚本读取文本文档，和系统里的所有包进行对比，按照一系列依赖计算，算出多余了哪些包，一下子卸载得没有残留。</p><p>这下，可以放心的实验各种桌面环境了，我列表定好，然后随便装什么包，不用关心装了多少东西，然后一条 spacman -a 命令直接把系统打回原样，这感觉就和虚拟机的快照一样。</p><p>秒切换桌面环境的梦实现了，实验效率能达到十分钟之内能体验五个桌面环境，而且迅速卸载无残留。</p><p>接下来开始先后体验了这些桌面环境。</p><h4 id="xfce4"><a class="markdownIt-Anchor" href="#xfce4"></a> xfce4</h4><p>这是我一开始的主力桌面环境，用了很久，启动速度有时候感觉慢了一点，虽然比windows快，美观也感觉差一些，虽然比lxde好些，基本功能挺全。</p><h4 id="lxde"><a class="markdownIt-Anchor" href="#lxde"></a> lxde</h4><p>追求轻量一般选择这个，lxqt也是类似，速度很快，就是功能少了点，美观也都没考虑，openbox能换换主题就不错了。</p><h4 id="kde"><a class="markdownIt-Anchor" href="#kde"></a> kde</h4><p>然后开始再次实验这个kde在archlinux下运行速度咋样。这经历不提了，我i3的cpu和机械硬盘，简直伤不起，进个桌面活活用了一分钟才稳定下来，不知道后台在干嘛，硬盘疯狂转，我的天哪，我好怕硬盘坏掉。。。。。赶紧注销执行 spacman -a，拜拜。</p><h4 id="gnome"><a class="markdownIt-Anchor" href="#gnome"></a> gnome</h4><p>这个桌面总的来说还行，但是不方便的一点就是通知栏显示QQ的问题，还有应用列表也没有很好的分类，或许可以配置但是没深究，流畅度还可以，没有像kde卡得那么夸张。不过还是不喜欢这么庞大的东西，不过我觉得对于很多人来说这个桌面环境是个不错的选择。</p><h4 id="mate"><a class="markdownIt-Anchor" href="#mate"></a> mate</h4><p>这是我后来才听说的桌面，各种组件也挺简约，但是面板自定制程度不高，还是不喜欢，也就没用多久。</p><h3 id="组件拆开的探索"><a class="markdownIt-Anchor" href="#组件拆开的探索"></a> 组件拆开的探索</h3><p>试了好几个桌面，发现还是xfce4最合我的口味，但是速度不理想而且美观程度一般。那我能不能把桌面组件全部拆开呢，自己来选择用什么面板用什么窗口管理器用什么文件管理器呢？</p><p>答案是可以的！linux正适合这样高度定制，尤其是 archlinux，而且我还发现了这个 <a href="https://wiki.archlinux.org/index.php/Desktop_environment_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E8%87%AA%E5%B7%B1%E6%89%93%E9%80%A0%E6%A1%8C%E9%9D%A2%E7%8E%AF%E5%A2%83" target="_blank" rel="noopener">打造自己的桌面环境的官方wiki</a> 。</p><p>可以配合 startx 来读取 ~/.xinitrc 文件配置，来实现自定制桌面环境，参见 <a href="https://wiki.archlinux.org/index.php/Xinit_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">archwiki-xinit</a>，当然这需要一定的 shell 脚本编写能力和实验探索精神。</p><p>思维打开之后，开始一个一个组件的研究，鉴于窗口管理器是一个桌面环境的基本组件，那先从窗口管理器开始试吧。</p><h4 id="选择窗口管理器"><a class="markdownIt-Anchor" href="#选择窗口管理器"></a> 选择窗口管理器</h4><p>xfwm是xfce自带，然后又试了openbox，然后了解到compiz，一开始对compiz不熟，但是用过之后，发现这窗口管理器太漂亮了，而且自定制程度简直秒杀所有窗口管理器。</p><h4 id="选择面板"><a class="markdownIt-Anchor" href="#选择面板"></a> 选择面板</h4><p>然后找面板，一共预选出三个面板：</p><ol><li><p>xfce4-panel</p><p>论面板，感觉 xfce4 的还是老大，电源管理的托盘、声音调整的图标，应用列表菜单，都很对胃口。</p></li><li><p>lxpanel</p><p>lxpanel 虽然也有 xfce4面板的基本功能，但是美观度差了点。</p></li><li><p>mate-panel</p><p>mate的面板定制程度不高，连顺序都不能自由调整，不嫌弃的话可以用。</p></li></ol><p>所以面板决定用 xfce4-panel 了。</p><h4 id="尝试-startx"><a class="markdownIt-Anchor" href="#尝试-startx"></a> 尝试 startx</h4><p>首先卸载所有桌面环境，然后安装 openbox，确保 xorg-server 和 xorg-xinit 也装上了才能 startx。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pacman -S xorg-xinit</span><br><span class="line">pacman -S openbox</span><br></pre></td></tr></table></figure><p>然后编辑文件 ~/.xinitrc</p><p>写入几行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openbox</span><br></pre></td></tr></table></figure><p>然后执行 startx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startx</span><br></pre></td></tr></table></figure><p>可以发现进入了 openbox 的界面，启动也很快。由于缺个终端，可以在 tty下装个终端，然后可以从 openbox 的右键打开，然后输入 xfce4-panel ，居然真的启动了面板，这样就很不错。</p><p>总结出，拆开组件的装，是完全可行的，那么把 xfce4-panel 也写入 .xinitrc 呢？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xfce4-panel &amp;</span><br><span class="line">openbox</span><br></pre></td></tr></table></figure><p>后面加了个 &amp; 符号是为了让它后台运行接着执行下一条命令，不至于卡住这等着面板被结束。</p><p>那怎么注销呢，只能用结束 openbox的命令代替注销了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall openbox</span><br></pre></td></tr></table></figure><p>然后，killall openbox ，再次 startx ，发现面板和窗口管理器都启动成功了。</p><p>上述要是哪里卡住，可以按 ctrl + alt + 1~6 来回到 tty，然后管理进程 killall 结束掉一些进程。</p><h4 id="会话管理器"><a class="markdownIt-Anchor" href="#会话管理器"></a> 会话管理器</h4><p>再后来的探索，发现，会话管理器也是一个桌面环境的组件之一，它的功能大概有管理启动项，掌控用户登录注销和开关机功能等。</p><p>启动项分为两类，一类是系统启动项，一类是用户启动项</p><h5 id="系统启动项"><a class="markdownIt-Anchor" href="#系统启动项"></a> 系统启动项</h5><p>启动项都是放在 /etc/xdg/autostart 里面的，可以看看哪些软件把自己加入了启动项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -Qo &#x2F;etc&#x2F;xdg&#x2F;autostart</span><br></pre></td></tr></table></figure><h5 id="用户启动项"><a class="markdownIt-Anchor" href="#用户启动项"></a> 用户启动项</h5><p>用户启动项放在 ~/.config/autostart 里面，通常由各个软件加入进去。</p><p>而我刚刚的 startx，只启动了 openbox 和 xfce4-panel</p><p>那么我可以不要会话管理器了，把一切启动项都交给 .xinitrc 管理怎么样？是不是好办法。</p><p>在 .xinitrc 里面写入（需要安装 exo）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if [ -d /etc/xdg/autostart ] ; then</span><br><span class="line"> for f in /etc/xdg/autostart/*.desktop ; do</span><br><span class="line">  exo-open "$f" &amp;</span><br><span class="line"> done</span><br><span class="line"> unset f</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>然后 killall openbox 再 startx ，发现启动项也全启动了，同理，用户启动项也可以这样干</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if [ -d ~/.config/autostart ] ; then</span><br><span class="line"> for f in ~/.config/autostart/*.desktop ; do</span><br><span class="line">  [ -x "$f" ] &amp;&amp; exo-open "$f" &amp;</span><br><span class="line"> done</span><br><span class="line"> unset f</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>加了一层判断，用 [ -x “$f” ] 来判断文件是否可执行，可执行才启动它，然后我可以去 ~/.config/autostart 用标记文件是否可执行的方式来管理用户启动项了。</p><p>例如开机启动 conky，创建一个 conky.desktop 到  ~/.config/autostart 里面，然后写入</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Desktop Entry]</span></span><br><span class="line"><span class="attr">Exec</span>=<span class="string">"conky"</span></span><br><span class="line"><span class="attr">Type</span>=Application</span><br></pre></td></tr></table></figure><p>然后将其设为可执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x ~/.config/autostart/conky.desktop</span><br></pre></td></tr></table></figure><p>然后再 killall openbox在 startx，可见 conky也启动了，类似的，所有自己想自定义让什么开机启动的，都可以这么设置</p><h4 id="完整的编写-xinitrc"><a class="markdownIt-Anchor" href="#完整的编写-xinitrc"></a> 完整的编写 .xinitrc</h4><p>对于自定制桌面环境组件来说，自己编写 .xinitrc 至关重要，在这里总结出它的功能，然后完整的编写</p><ol><li>管理会话，startx会启动此脚本，此脚本运行完意味着 startx 的结束，会回到 tty。</li><li>启动面板、窗口管理器等组件</li><li>管理系统启动项、用户启动项</li></ol><p>由于每次 killall openbox 很麻烦，而且万一 openbox 出bug崩溃岂不是所有进程都会强制退出，要是没保存什么文档岂不是悲剧，想个什么办法才能维持 startx 的运行呢？</p><p>可以想到办法，用 sleep 代替</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sleep 3650000d</span><br></pre></td></tr></table></figure><p>这条语句的意思是等待一万年，放到 .xinitrc 的最后，怎么样，不怕 openbox 崩溃了吧。但是引发另一个问题，如何注销？killall sleep 吗？万一我某些别的脚本正在 sleep 怎么办，岂不是一起结束了？改名吧。最终方案是把 sleep 这个二进制文件复制到 /tmp/ 里面的某个地方改成别的名字，然后启动它，这样进程名就不是 sleep了，可以指定 pid 杀死进程，把 pid 也保存到 /tmp/目录吧，最终代码如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> deamon process</span></span><br><span class="line">daemon_dir=/tmp/xinitrc_deamon_$USER</span><br><span class="line">mkdir -p $daemon_dir</span><br><span class="line">cp -f /usr/bin/sleep $daemon_dir/xinitrc_deamon_$USER</span><br><span class="line"><span class="meta">$</span><span class="bash">daemon_dir/xinitrc_deamon_<span class="variable">$USER</span> 3650000d &amp;</span></span><br><span class="line">main_pid=$!</span><br><span class="line">echo $main_pid &gt; $daemon_dir/pid</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">### 各个启动项（注意每个启动项后面都要加 &amp; ，防止停住）</span></span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">wait $main_pid</span><br></pre></td></tr></table></figure><h4 id="输入法问题"><a class="markdownIt-Anchor" href="#输入法问题"></a> 输入法问题</h4><p>装 fcitx 的中文输入法（如搜狗拼音）要配置环境变量，网上很多都是说配置到 ~/.xprofile 里面，而自己组件拆开是默认不会读取这个文件的。所以，在 .xinitrc 开头加上读取，兼容这一特点。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ -f ~/.xprofile ] &amp;&amp; . ~/.xprofile</span><br></pre></td></tr></table></figure><p>用 startx 启动的时候，为了让中文输入法正常工作，需要五个环境变量，这是我的 .xprofile</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export GTK_IM_MODULE=fcitx</span><br><span class="line">export QT_IM_MODULE=fcitx</span><br><span class="line">export XMODIFIERS="@im=fcitx"</span><br><span class="line"></span><br><span class="line">export LANG="zh_CN.UTF-8"</span><br><span class="line">export LC_CTYPE="zh_CN.UTF-8"</span><br></pre></td></tr></table></figure><p>当然 LANG 和 LC_CTYPE 这两个环境变量可能在桌面管理器的配置里面配置好了，但是 startx 的时候是没配置的，所以这两个再在这里面写一遍，兼容所有。</p><h2 id="各个组件的选择"><a class="markdownIt-Anchor" href="#各个组件的选择"></a> 各个组件的选择</h2><p>下面列出我几个桌面环境组件目前的选择</p><h3 id="窗口管理器"><a class="markdownIt-Anchor" href="#窗口管理器"></a> 窗口管理器</h3><p>窗口管理器我选择 compiz，原因很简单，超级美观，堪比 vista，而且所有颜色自定义，所有动画自定义，所有快捷键功能自定义，设置多的研究不过来，找不到比它更爽是桌面管理器了。</p><p><img src="/img/ccsm-1.png" alt="" /><br /><img src="/img/ccsm-2.png" alt="" /><br /><img src="/img/ccsm-3.png" alt="" /><br /><img src="/img/emerald-1.png" alt="" /><br /><img src="/img/emerald-2.png" alt="" /><br /><img src="/img/emerald-3.png" alt="" /><br /><img src="/img/emerald-4.png" alt="" /></p><p>安装方法也很简单，在 AUR 里面安装compiz-core、ccsm、emerald 即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S ccsm compiz-core emerald</span><br></pre></td></tr></table></figure><p>装完后，启动也很简单，直接 compiz 就可以，将它写入 .xinitrc，替换掉 openbox</p><p>定制：</p><ol><li><p>运行 ccsm，就可以打开 compiz 的设置，可以进行快捷键、窗口动画等等设置。</p><p>还有更多设置扩展，觉得定制不过瘾的，都可以选择性的安装如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yay -S compiz-fusion-plugins-main</span><br><span class="line">yay -S compiz-fusion-plugins-extra</span><br><span class="line">yay -S compiz-fusion-plugins-experimental</span><br></pre></td></tr></table></figure></li><li><p>运行 emerald-theme-manager 就可以进行装饰器的主题定制，还可以装一些已经有的主题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S emerald-themes</span><br></pre></td></tr></table></figure><p>我基于其中一个主题定制成了高仿 wista 和win7的主题，也上传到了aur包名是 emerald-theme-qaz-blue-vista</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S emerald-theme-qaz-blue-vista</span><br></pre></td></tr></table></figure></li></ol><p>以上的定制，只是对窗口管理器的定制，边框等等，至于窗口内元素颜色等等，可以用 gtk主题去设置（后面有讲到）。</p><p>当然，最后必须说明的是，在 archlinux 里选择 compiz 还是有一些缺点的：</p><ol><li>由于没进入官方仓库，每次更新安装都得从 aur 编译，编译需要时间，还有就是，当arch官方仓库的一些底层库（如 protobuf）版本大更新的时候，compiz 就会出现问题，会找不到库，需要重新从 aur 编译。</li><li>有时候开机会小概率的出现装饰器启动不了 bug，也就是窗口没有边框都关闭之类的没有，我也不知道是怎么回事，出现这个bug的时候，可以打开终端运行 nohup emerald --replace &gt;/dev/null &amp; 暂时解决。</li></ol><h3 id="面板"><a class="markdownIt-Anchor" href="#面板"></a> 面板</h3><p>面板我选 xfce4-panel，因为以下组件很容易配合 xfce4-panel 来添加托盘图标运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pacman -S xfce4-pulseaudio-plugin  # pulseaudio 音量管理插件（仅支持 xfce4 面板）</span><br><span class="line">pacman -S xfce4-power-manager   # xfce4 的电源管理器</span><br><span class="line">pacman -S xfce4-whiskermenu-plugin   # 美化的 xfce4 菜单</span><br></pre></td></tr></table></figure><p>另外，还需要解决两个问题</p><ol><li><p>xfce4-panel 配合 compiz 会有些bug，工作区切换会有问题，不过有大神修改了 xfce4-panel的源码修复这些 bug，上传到了 aur，可以直接用，替换掉 xfce4-panel</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S xfce4-panel-compiz</span><br></pre></td></tr></table></figure><p>但是有一次，xfce4-panel 来了一次大更新，而 aur 上的 xfce4-panel-compiz 迟迟没有更新，我没办法就用了一段时间的 lxpanel</p></li><li><p>无会话时 whiskermenu 菜单的注销按钮和锁定屏幕的按钮是不管用的。</p><p>我研究过这个问题，单击这俩按钮时，会分别执行 /usr/bin/xflock4 和 /usr/bin/xfce4-session-logout ，那么，这两个可执行程序，我可以自己写 shell 脚本代替。为了方便的解决这个问题，我打包上传到了 aur，符号链接的方式到 /etc/xdg/xfce4/whiskermenu/，方便配合包管理器解决这个问题。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S xfce4-whiskermenu-plugin-button</span><br></pre></td></tr></table></figure><p>然后自己编写 /etc/xdg/xfce4/whiskermenu/xfce4-session-logout 和 /etc/xdg/xfce4/whiskermenu/xflock4 ，就可以定义这两个按钮的行为了。</p></li></ol><h3 id="会话管理器-2"><a class="markdownIt-Anchor" href="#会话管理器-2"></a> 会话管理器</h3><p>前面说过，自己编写的 .xinitrc 脚本来定制启动项，另外，根据 archwiki 的推荐，<a href="https://wiki.archlinux.org/index.php/Oblogout" target="_blank" rel="noopener">oblogout</a> 是不错的选择</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S oblogout</span><br></pre></td></tr></table></figure><p>然后执行 oblogout 即可弹出几个按钮，可以实现注销关机等等。里面每个按钮都可以自定义行为，修改 /etc/oblogout.conf 以下是我的配置</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[settings]</span></span><br><span class="line"><span class="attr">usehal</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="section">[looks]</span></span><br><span class="line"><span class="attr">opacity</span> = <span class="number">70</span></span><br><span class="line"><span class="attr">bgcolor</span> = black</span><br><span class="line"><span class="attr">buttontheme</span> = oxygen</span><br><span class="line"><span class="attr">buttons</span> = logout, restart, shutdown, suspend, lock, cancel</span><br><span class="line"></span><br><span class="line"><span class="section">[shortcuts]</span></span><br><span class="line"><span class="attr">cancel</span> = Escape</span><br><span class="line"><span class="attr">shutdown</span> = S</span><br><span class="line"><span class="attr">restart</span> = R</span><br><span class="line"><span class="attr">suspend</span> = U</span><br><span class="line"><span class="attr">logout</span> = L</span><br><span class="line"><span class="attr">hibernate</span> = H</span><br><span class="line"><span class="attr">lock</span> = K</span><br><span class="line"></span><br><span class="line"><span class="section">[commands]</span></span><br><span class="line"><span class="attr">shutdown</span> = systemctl power<span class="literal">off</span></span><br><span class="line"><span class="attr">restart</span> = systemctl reboot</span><br><span class="line"><span class="attr">suspend</span> = systemctl suspend</span><br><span class="line"><span class="attr">hibernate</span> = systemctl hibernate</span><br><span class="line"><span class="attr">logout</span> = xlogout</span><br><span class="line"><span class="attr">lock</span> = dm-tool switch-to-greeter</span><br><span class="line"><span class="comment">#safesuspend = safesuspend</span></span><br></pre></td></tr></table></figure><p>其中呢，logout = xlogout 注销是我自己配合 .xinitrc 写的，在 /usr/local/bin/xlogout 里面，就一行代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">daemon_dir=/tmp/xinitrc_deamon_$USER</span><br><span class="line">kill "$(cat $daemon_dir/pid)"</span><br></pre></td></tr></table></figure><p>还有 lock = dm-tool switch-to-greeter 这一行，dm-tool 是 lightdm 的组件，如果没用 lightdm，那这条命令是无效的可以删掉。</p><p>如果要用 lightdm 或者其它桌面管理器，那么可以从 aur 装这个包，把自己编写的 .xinitrc 作为会话管理器，来让桌面管理器操控</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S xinit-xsession</span><br></pre></td></tr></table></figure><h3 id="终端"><a class="markdownIt-Anchor" href="#终端"></a> 终端</h3><p>我一直使用的是不用配置的 xfce4 终端，可以根据自己喜好选择别的终端。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S xfce4-terminal</span><br></pre></td></tr></table></figure><h3 id="polkit-身份认证组件"><a class="markdownIt-Anchor" href="#polkit-身份认证组件"></a> polkit 身份认证组件</h3><p>这个组件几乎每个桌面环境都带个，也就是当执行 systemctl 修改系统配置的时候或者其它地方申请权限的时候，会弹出一个对话框申请权限，让你输入密码，大概有这些。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># polkit 身份认证组件</span></span><br><span class="line">polkit-gnome  # gnome 默认简易的身份认证</span><br><span class="line"><span class="comment">#lxqt-policykit  # lxqt 的身份认证</span></span><br><span class="line"><span class="comment">#mate-polkit  # mate 的身份认证</span></span><br><span class="line"><span class="comment">#deepin-polkit-agent  # deepin 的身份认证</span></span><br></pre></td></tr></table></figure><p>在都试了的情况下，对于颜色简约等等，我选择的是 polkit-gnome</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S polkit-gnome</span><br></pre></td></tr></table></figure><p>这个服务也需要开机自启，将以下行写入 .xinitrc</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> polkit</span></span><br><span class="line">/usr/lib/polkit-gnome/polkit-gnome-authentication-agent-1 &amp;</span><br></pre></td></tr></table></figure><h3 id="通知服务"><a class="markdownIt-Anchor" href="#通知服务"></a> 通知服务</h3><p>通知服务也是一个比较重要的组件之一，当某些软件想发送通知时，右上角会弹出一个漂浮的窗口来提醒用户，也可以 shell 执行来主动发送通知，参见 <a href="https://wiki.archlinux.org/index.php/Desktop_notifications#Bash" target="_blank" rel="noopener">archwiki用bash发送通知</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">notify-send 'Hello world!' 'This is an example notification.' --icon=dialog-information</span><br></pre></td></tr></table></figure><p><img src="/img/nodify.png" alt="" /></p><p>它需要一个后台的通知服务程序才能生效，有以下通知服务程序（摘取自<a href="https://github.com/fkxxyz/archlinux-config/blob/master/spacman/spacman.conf" target="_blank" rel="noopener">我的软件列表</a>）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 通知服务</span></span><br><span class="line"><span class="meta">#</span><span class="bash">lxqt-notificationd <span class="comment"># lxqt 的简易通知服务</span></span></span><br><span class="line">xfce4-notifyd  # xfce4 通知服务</span><br><span class="line"><span class="meta">#</span><span class="bash">mate-notification-daemon <span class="comment"># mate 的通知服务</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">notification-daemon <span class="comment"># gnome 最原始的通知服务</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">notify-osd <span class="comment"># unity 的通知服务</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">statnot  <span class="comment"># 使用python2实现的简易通知脚本</span></span></span><br></pre></td></tr></table></figure><p>也是颜色字体等等各有各的特点，我最终选择的是 xfce4-notifyd。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S xfce4-notifyd</span><br></pre></td></tr></table></figure><p>当然，要让他开机自启，将以下行写入 .xinitrc</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/lib/xfce4/notifyd/xfce4-notifyd &amp;</span><br></pre></td></tr></table></figure><h3 id="文件管理器与桌面"><a class="markdownIt-Anchor" href="#文件管理器与桌面"></a> 文件管理器与桌面</h3><p>上面没有提到过桌面背景，用 compiz 的时候桌面背景是黑的怎么办呢。得装上一个文件管理器，把文件管理器设为自动启动才可以，有以下文件管理器。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件管理器与桌面</span></span><br><span class="line"><span class="comment">#thunar</span></span><br><span class="line"><span class="comment">#xfdesktop  # xfce 桌面</span></span><br><span class="line"><span class="comment">#thunar-volman  # 可移动设备管理</span></span><br><span class="line"><span class="comment">#thunar-archive-plugin  # 压缩解压插件</span></span><br><span class="line"><span class="comment">#thunar-media-tags-plugin # 媒体文件标签插件</span></span><br><span class="line"><span class="comment">#tumbler  # 访问文件的缩略图支持</span></span><br><span class="line"><span class="comment">#pcmanfm    # lxde 的文件管理器和桌面</span></span><br><span class="line">feh   # 命令行图片查看器（可用来显示壁纸）</span><br><span class="line"><span class="comment">#pcmanfm-qt    # lxqt 的文件管理器</span></span><br><span class="line"><span class="comment">#deepin-file-manager  # deepin 的文件管理器</span></span><br><span class="line"><span class="comment">#nemo  # Cinnamon 的文件管理器</span></span><br><span class="line"><span class="comment">#nautilus  # gnome 的文件管理器</span></span><br><span class="line"><span class="comment">#caja  # mate 的文件管理器</span></span><br></pre></td></tr></table></figure><p>这个可以根据自己的喜好选择，我曾经用过一段时间的 thunar ，后来换成了 feh 来显示壁纸，不需要文件管理器了，因为对我来说，用shell命令行管理文件比图形界面个管理器要高效的多。</p><p>用文件管理器，也需要将它加入 .xinitrc 开机启动。</p><p>下面以 pcmanfm 为例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pcmanfm --desktop &amp;</span><br></pre></td></tr></table></figure><p>其它文件管理器如何显示桌面，看其 --help 即可</p><p>我用的是 feh 显示壁纸</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">feh --bg-scale &lt;壁纸路径&gt;</span><br></pre></td></tr></table></figure><p>用 feh 的好处是，没有后台进程。设置了壁纸了之后，会在家目录生成一个脚本文件</p><p>cat ~/.fehbg</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">feh --no-fehbg --bg-scale '/usr/share/wallpapers/deepin/Scenery_in_Plateau_by_Arto_Marttinen.jpg'</span><br></pre></td></tr></table></figure><p>所以很方便的将 feh加入到 .xinitrc</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> wallpaper</span></span><br><span class="line">~/.fehbg &amp;</span><br></pre></td></tr></table></figure><p>壁纸的安装也有很多包提供，也可以自己到网上找图片。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 壁纸</span></span><br><span class="line">mate-backgrounds</span><br><span class="line">gnome-backgrounds</span><br><span class="line">deepin-community-wallpapers</span><br><span class="line">archlinux-wallpaper</span><br><span class="line">deepin-wallpapers</span><br><span class="line">xfce4-artwork</span><br><span class="line">deepin-wallpapers-plasma</span><br></pre></td></tr></table></figure><p>另外，配合 feh 我还遍了两个脚本，可以实现一键切换并设置到下一个或上一个壁纸，自定义壁纸路径，自行体会吧</p><p>cat ~/.config/wallpaper-path.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;share&#x2F;backgrounds</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;wallpapers</span><br></pre></td></tr></table></figure><p>cat wallpaper-next</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">path_conf=~/.config/wallpaper-path.conf</span><br><span class="line"></span><br><span class="line">p_now="$(tail -1 ~/.fehbg | cut -d"'" -f2)"</span><br><span class="line">p_all="$(find $(cat "$path_conf") -path \*.jpg -type f)"</span><br><span class="line">p_next="$(echo "$p_all" | sed -n '/'$&#123;p_now//\//\\/&#125;'/&#123;n;p&#125;')"</span><br><span class="line">[ "$&#123;#p_next&#125;" == "0" ] &amp;&amp; p_next="$(echo "$p_all" | head -1)"</span><br><span class="line"></span><br><span class="line">feh --bg-scale "$p_next"</span><br></pre></td></tr></table></figure><p>cat wallpaper-prev</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">path_conf=~/.config/wallpaper-path.conf</span><br><span class="line"></span><br><span class="line">p_now="$(tail -1 ~/.fehbg | cut -d"'" -f2)"</span><br><span class="line">p_all="$(find $(cat "$path_conf") -path \*.jpg -type f)"</span><br><span class="line">p_next="$(echo "$p_all" | sed -n '/'$&#123;p_now//\//\\/&#125;'/&#123;x;p&#125;;h')"</span><br><span class="line">[ "$&#123;#p_next&#125;" == "0" ] &amp;&amp; p_next="$(echo "$p_all" | tail -1)"</span><br><span class="line"></span><br><span class="line">feh --bg-scale "$p_next"</span><br></pre></td></tr></table></figure><p>将这两个脚本设为 compiz 的快捷键，直接按键就能切换壁纸。</p><h3 id="设置"><a class="markdownIt-Anchor" href="#设置"></a> 设置</h3><p>我发现还缺少个设置程序，我目前用的 xfce4-setting ，而且正好 deepin-wine 的QQ是依赖这个组件的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S xfce4-setting</span><br></pre></td></tr></table></figure><p>也可以选择 lxde 的一些设置程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#lxinput  # lxde 鼠标键盘偏好设置</span><br><span class="line">#lxrandr  # lxde 显示器设置</span><br><span class="line">#lxappearance  # lxde 自定义外观和体验</span><br></pre></td></tr></table></figure><p>包括 gtk 主题也是在这里设置，可以设置样式、图标等等，这些有区别于 compiz 的窗口外观设置。</p><p><img src="/img/gtk-style.png" alt="" /></p><p>这些主题在这些软件包里面包含，可以都装上，然后自己慢慢选择。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主题和图标</span></span><br><span class="line">gnome-icon-theme</span><br><span class="line">lxde-icon-theme</span><br><span class="line">mate-themes</span><br><span class="line">mate-icon-theme</span><br><span class="line">gtk-engine-murrine</span><br><span class="line">papirus-icon-theme</span><br><span class="line">arc-gtk-theme</span><br><span class="line">arc-icon-theme</span><br><span class="line">deepin-icon-theme</span><br><span class="line">deepin-gtk-theme</span><br><span class="line">adapta-gtk-theme</span><br><span class="line">numix-icon-theme-git</span><br><span class="line">numix-circle-icon-theme-git</span><br><span class="line">vertex-themes</span><br></pre></td></tr></table></figure><p>为了方便的预览主题，可以从 aur 安装 awf-git 这个包，切换主题可以实时预览各种控件元素的样式。</p><h3 id="网络连接管理器"><a class="markdownIt-Anchor" href="#网络连接管理器"></a> 网络连接管理器</h3><p>管理网络一般我用的是命令行版的 networkmanager 的 nmcli 命令。图形界面的话，network-manager-applet 就是 nmcli 的前端，它也是 gnome 默认的网络连接管理器，暂时找不到替代</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S network-manager-applet</span><br></pre></td></tr></table></figure><p>设置网络连接和连接 wifi 都很方便，tty 里面也可以用 nmcli 管理网络</p><h3 id="其它软件"><a class="markdownIt-Anchor" href="#其它软件"></a> 其它软件</h3><p>其它还有很多很多组件，如计算器、截图工具、图片查看器、归档管理器、浏览器、音乐播放器、文本编辑器、pdf阅读器、录音工具、录屏工具、计时器等等，大多数桌面环境都是自带这些，都可以去尝试，如果喜欢别的哪个桌面环境的某个组件，都可以直接装到自己这里，出了 kde 的组件之外，别的桌面环境的组件依赖都很少，喜欢的话可以直接拿过来用。</p><p>可以继续参见<a href="https://github.com/fkxxyz/archlinux-config/blob/master/spacman/spacman.conf" target="_blank" rel="noopener">我的试过的所有软件列表</a>，看看我装过的所有软件，同时也希望大家推荐给我一些更好用的软件。</p><h2 id="我的完整-xinitrc-配置"><a class="markdownIt-Anchor" href="#我的完整-xinitrc-配置"></a> 我的完整 .xinitrc 配置</h2><p>贴上我完整的 .xinitrc 配置，当你看到这篇博客的时候可能很旧了，最新的配置在<a href="https://github.com/fkxxyz/archlinux-config/blob/master/xorg-xinit/.xinitrc" target="_blank" rel="noopener">我的github的xorg-xinit设置</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[ -f ~/.xprofile ] &amp;&amp; . ~/.xprofile</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> deamon process</span></span><br><span class="line">daemon_dir=/tmp/xinitrc_deamon_$USER</span><br><span class="line">mkdir -p $daemon_dir</span><br><span class="line">cp -f /usr/bin/sleep $daemon_dir/xinitrc_deamon_$USER</span><br><span class="line"><span class="meta">$</span><span class="bash">daemon_dir/xinitrc_deamon_<span class="variable">$USER</span> 3650000d &amp;</span></span><br><span class="line">main_pid=$!</span><br><span class="line">echo $main_pid &gt; $daemon_dir/pid</span><br><span class="line"></span><br><span class="line">export &gt; $daemon_dir/xrun</span><br><span class="line">echo 'exec "$@"' &gt;&gt; $daemon_dir/xrun</span><br><span class="line">chmod +x $daemon_dir/xrun</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> wallpaper</span></span><br><span class="line">~/.fehbg &amp;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> window manager</span></span><br><span class="line">compiz &amp;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> nodify</span></span><br><span class="line">/usr/lib/xfce4/notifyd/xfce4-notifyd &amp;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> polkit</span></span><br><span class="line">/usr/lib/polkit-gnome/polkit-gnome-authentication-agent-1 &amp;</span><br><span class="line"></span><br><span class="line">if [ -d /etc/xdg/autostart ] ; then</span><br><span class="line"> for f in /etc/xdg/autostart/*.desktop ; do</span><br><span class="line">  exo-open "$f" &amp;</span><br><span class="line"> done</span><br><span class="line"> unset f</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> panel</span></span><br><span class="line">xfce4-panel &amp;</span><br><span class="line"></span><br><span class="line">if [ -d ~/.config/autostart ] ; then</span><br><span class="line"> for f in ~/.config/autostart/*.desktop ; do</span><br><span class="line">  [ -x "$f" ] &amp;&amp; exo-open "$f" &amp;</span><br><span class="line"> done</span><br><span class="line"> unset f</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">wait $main_pid</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> archlinux </tag>
            
            <tag> 桌面环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 linux 发行版中，python 多版本共存并自由切换</title>
      <link href="/c/python-env/"/>
      <url>/c/python-env/</url>
      
        <content type="html"><![CDATA[<p>最近有多个 python 版本共存的需求，在 archlinux 下只能 python3.8，而阿里云的 python 是 3.6，而且环境和库各不相同。包管理器也影响其存在。然后搜到了 pyenv 这个神器，这个项目直接解决了我所有遇到的 python 不同版本共存和切换的问题，不解释了，直接看<a href="https://github.com/pyenv/pyenv#simple-python-version-management-pyenv" target="_blank" rel="noopener">官方介绍</a>。</p><a id="more"></a><h2 id="pyenv-的原理"><a class="markdownIt-Anchor" href="#pyenv-的原理"></a> pyenv 的原理</h2><h3 id="选择python版本"><a class="markdownIt-Anchor" href="#选择python版本"></a> 选择Python版本</h3><p>这里直接引用官方的<a href="https://github.com/pyenv/pyenv#choosing-the-python-version" target="_blank" rel="noopener">原文</a></p><blockquote><p>执行填充程序时，pyenv通过从以下来源按以下顺序读取来确定要使用的Python版本：</p><ol><li>在<code>PYENV_VERSION</code>环境变量（如果指定）。您可以使用该<a href="https://github.com/pyenv/pyenv/blob/master/COMMANDS.md#pyenv-shell" target="_blank" rel="noopener"><code>pyenv shell</code></a>命令在当前的Shell会话中设置此环境变量。</li><li><code>.python-version</code>当前目录中的特定于应用程序的文件（如果存在）。您可以<code>.python-version</code>使用以下<a href="https://github.com/pyenv/pyenv/blob/master/COMMANDS.md#pyenv-local" target="_blank" rel="noopener"><code>pyenv local</code></a> 命令修改当前目录的 文件。</li><li><code>.python-version</code>通过搜索每个父目录找到第一个文件（如果有），直到到达文件系统的根目录为止。</li><li>全局<code>$(pyenv root)/version</code>文件。您可以使用<a href="https://github.com/pyenv/pyenv/blob/master/COMMANDS.md#pyenv-global" target="_blank" rel="noopener"><code>pyenv global</code></a>命令修改此文件。如果不存在全局版本文件，则pyenv假定您要使用“系统” Python。（换句话说，如果您没有pyenv，则可以运行任何版本 <code>PATH</code>。）</li></ol></blockquote><h2 id="pyenv-的使用速查"><a class="markdownIt-Anchor" href="#pyenv-的使用速查"></a> pyenv 的使用速查</h2><p>我把这一章放到最开头，作为速查命令</p><h3 id="安装-python"><a class="markdownIt-Anchor" href="#安装-python"></a> 安装 python</h3><p>列出所有可以安装的版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pyenv install --list</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或</span></span><br><span class="line">pyenv install -l</span><br></pre></td></tr></table></figure><p>只列出 python 的版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv install -l | grep '^ *[0-9]'</span><br></pre></td></tr></table></figure><p>安装一个版本（例如 3.6.9）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pyenv install 3.6.9</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果卡在下载源码上，可以手动下载源码，放到 ~/.pyenv/cache 里。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果源码已经被放在了 ~/.pyenv/cache/Python-3.6.9.tar.xz 那么就不会下载了，直接解压编译。</span></span><br></pre></td></tr></table></figure><h3 id="查询版本"><a class="markdownIt-Anchor" href="#查询版本"></a> 查询版本</h3><h4 id="查看当前选择的-python-版本"><a class="markdownIt-Anchor" href="#查看当前选择的-python-版本"></a> 查看当前选择的 python 版本</h4><p>该命令会提示当前环境如果执行 python 的话，会启动的 python 版本，以及如何选择的 python 版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv version</span><br></pre></td></tr></table></figure><h4 id="查看所有可选择的-python-版本"><a class="markdownIt-Anchor" href="#查看所有可选择的-python-版本"></a> 查看所有可选择的 python 版本</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv versions</span><br></pre></td></tr></table></figure><h3 id="切换选择-python-版本"><a class="markdownIt-Anchor" href="#切换选择-python-版本"></a> 切换选择 python 版本</h3><h4 id="以全局方式选择-python-版本"><a class="markdownIt-Anchor" href="#以全局方式选择-python-版本"></a> 以全局方式选择 python 版本</h4><p>这种方式全局生效，在任意的 shell 调用 python 时，都会以设置的 python 版本启动。</p><p>查看全局 python 版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv global</span><br></pre></td></tr></table></figure><p>设置全局 python 版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv global 3.6.9</span><br></pre></td></tr></table></figure><h4 id="以目录模式选择-python-版本"><a class="markdownIt-Anchor" href="#以目录模式选择-python-版本"></a> 以目录模式选择 python 版本</h4><p>此方式可以把某个目录设为特定版本的 python，设置时会在这个目录里写入 .python_version 文件</p><p>查看当前目录的 python 版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv local</span><br></pre></td></tr></table></figure><p>设置当前目录的 python 版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv local 3.6.9</span><br></pre></td></tr></table></figure><h4 id="以-shell-环境模式选择-python-版本"><a class="markdownIt-Anchor" href="#以-shell-环境模式选择-python-版本"></a> 以 shell 环境模式选择 python 版本</h4><p>此方式可以把当前 shell 环境设置为特定版本的 python，设置时会改变 PYENV_VERSION 这个环境变量</p><p>查看当前 shell 的 python 版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv shell</span><br></pre></td></tr></table></figure><p>设置当前 shell 的 python 版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv shell 3.6.9</span><br></pre></td></tr></table></figure><h2 id="pyenv-的安装"><a class="markdownIt-Anchor" href="#pyenv-的安装"></a> pyenv 的安装</h2><h3 id="安装-pyenv"><a class="markdownIt-Anchor" href="#安装-pyenv"></a> 安装 pyenv</h3><p>在 archlinux 发行版中，由于官方仓库自带 pyenv ，直接安装即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S pyenv</span><br></pre></td></tr></table></figure><p>在其它不带 pyenv 的 linux 的发行版中，pyenv的github文档给出了详细的<a href="https://github.com/pyenv/pyenv#installation" target="_blank" rel="noopener">安装过程</a>，可以按照官方给出的<a href="https://github.com/pyenv/pyenv-installer#installation--update--uninstallation" target="_blank" rel="noopener">安装器</a>这样安装（如果没有 git 需要先装 git）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https:&#x2F;&#x2F;pyenv.run | bash</span><br></pre></td></tr></table></figure><p>此命令克隆仓库到 ~/.pyenv 下，可执行文件在 ~/.pyenv/bin 可以看到里面只有一个 pyenv 符号链接指向 …/libexec/pyenv</p><h3 id="pyenv-的环境配置"><a class="markdownIt-Anchor" href="#pyenv-的环境配置"></a> pyenv 的环境配置</h3><p>官方给出了详细的<a href="https://github.com/pyenv/pyenv#basic-github-checkout" target="_blank" rel="noopener">配置</a>过程，那么就搬运官方给的原命令</p><ol><li><p>如果用的 bash ，则修改 ~/.bash_profile</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo 'export PYENV_ROOT="$HOME/.pyenv"' &gt;&gt; ~/.bash_profile</span><br><span class="line">echo 'export PATH="$PYENV_ROOT/bin:$PATH"' &gt;&gt; ~/.bash_profile</span><br></pre></td></tr></table></figure></li><li><p>如果用的 zsh， 则修改 ~/.zshenv</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo 'export PYENV_ROOT="$HOME/.pyenv"' &gt;&gt; ~/.zshenv</span><br><span class="line">echo 'export PATH="$PYENV_ROOT/bin:$PATH"' &gt;&gt; ~/.zshenv</span><br></pre></td></tr></table></figure></li></ol><p>然后重启 shell ，使配置生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec $SHELL</span><br></pre></td></tr></table></figure><p>现在，可以执行 pyenv 了，试试吧</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv</span><br></pre></td></tr></table></figure><p>若输出一大堆 pyenv 的帮助，则代表配置生效啦。</p><h3 id="python-环境配置"><a class="markdownIt-Anchor" href="#python-环境配置"></a> python 环境配置</h3><p>先执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv init</span><br></pre></td></tr></table></figure><p>可以看到提示，将这个提示加入到他所说的文件中吧</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> bash 下执行</span></span><br><span class="line">pyenv init 2&gt;&gt; ~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> zsh 下执行</span></span><br><span class="line">pyenv init 2&gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure><p>然后执行 exec $SHELL 生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec $SHELL</span><br></pre></td></tr></table></figure><p>查看是否成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $PATH</span><br></pre></td></tr></table></figure><p>如果看到开头为 /home/用户名/.pyenv/shims 则配置算生效啦。</p><h2 id="安装不同版本的-python"><a class="markdownIt-Anchor" href="#安装不同版本的-python"></a> 安装不同版本的 python</h2><h3 id="准备编译环境"><a class="markdownIt-Anchor" href="#准备编译环境"></a> 准备编译环境</h3><p>这一步可谓是至关重要，由于忽略这个问题而直接编译 python，在 centos 上，默认很多所需的包没装，那么编译的时候就会没有把相应的功能编译进去，造成后续使用的时候出现一些问题。</p><p>按照<a href="https://devguide.python.org/setup/#linux" target="_blank" rel="noopener">python官方的开发者文档安装依赖</a>这一章，可以快速补上需要的依赖。</p><p>在 yum 包管理器管理的系统中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install yum-utils</span><br><span class="line">sudo yum-builddep python3</span><br></pre></td></tr></table></figure><p>在 dnf 包管理器管理的系统中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf install dnf-plugins-core  # install this to use 'dnf builddep'</span><br><span class="line">sudo dnf builddep python3</span><br></pre></td></tr></table></figure><p>在 debian 系的发行版中，看官方说明吧，等我要用到的时候再总结到这里。</p><blockquote><p>在<strong>Debian</strong>，<strong>Ubuntu</strong>和其他<code>apt</code>基于系统的系统上，尝试通过使用<code>apt</code>命令获取正在使用的Python的依赖关系。</p><p>首先，请确保已在“来源”列表中启用了源软件包。您可以通过将源码包的位置（包括URL，发行名称和组件名称）添加到中来实现<code>/etc/apt/sources.list</code>。以Ubuntu Bionic为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deb-src http:&#x2F;&#x2F;archive.ubuntu.com&#x2F;ubuntu&#x2F; bionic main</span><br></pre></td></tr></table></figure><p>对于其他发行版，例如Debian，请更改URL和名称以与特定发行版相对应。</p><p>然后，您应该更新软件包索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br></pre></td></tr></table></figure><p>现在，您可以通过<code>apt</code>以下方式安装构建依赖项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get build-dep python3.6</span><br></pre></td></tr></table></figure></blockquote><h3 id="下载-python-源码"><a class="markdownIt-Anchor" href="#下载-python-源码"></a> 下载 python 源码</h3><p>虽然 pyenv 可以自动从 python 的官网下载源码，但是尝试过之后，发现一直卡住速度较慢。</p><p>可以从国内任意含有 gentoo 仓库的镜像站来下载一部分 python 源码。</p><blockquote><p>3.8.0 版本</p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/gentoo/distfiles/Python-3.8.0.tar.xz" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/gentoo/distfiles/Python-3.8.0.tar.xz</a></p><p>3.7.5 版本</p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/gentoo/distfiles/Python-3.7.5.tar.xz" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/gentoo/distfiles/Python-3.7.5.tar.xz</a></p><p>3.6.9 版本</p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/gentoo/distfiles/Python-3.6.9.tar.xz" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/gentoo/distfiles/Python-3.6.9.tar.xz</a></p><p>3.5.9 版本</p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/gentoo/distfiles/Python-3.5.9.tar.xz" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/gentoo/distfiles/Python-3.5.9.tar.xz</a></p><p>2.7.17 版本</p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/gentoo/distfiles/Python-2.7.17.tar.xz" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/gentoo/distfiles/Python-2.7.17.tar.xz</a></p></blockquote><p>不一定有所有的版本，但包含很多常用的版本了，大概是够用了。</p><p>将他们下载到 ~/.pyenv/cache 下，先创建这个目录吧</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd</span><br><span class="line">cd .pyenv</span><br><span class="line">mkdir cache</span><br><span class="line">cd cache</span><br></pre></td></tr></table></figure><p>然后开始下载，例如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/gentoo/distfiles/Python-3.6.9.tar.xz</span><br></pre></td></tr></table></figure><h3 id="用-pyenv-安装-python"><a class="markdownIt-Anchor" href="#用-pyenv-安装-python"></a> 用 pyenv 安装 python</h3><p>如果源码已经被放在 ~/.pyenv/cache 里了，那么在执行安装就很快了。</p><p>列出所有可安装的版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv install --list</span><br></pre></td></tr></table></figure><p>安装指定版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pyenv install 3.6.9</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果上一步，源码已经被放在了 ~/.pyenv/cache/Python-3.6.9.tar.xz 那么这一步就不会下载了，直接解压编译。</span></span><br></pre></td></tr></table></figure><p>等到输出如下信息时，代表安装成功了。</p><blockquote><p>Installed Python-3.6.9 to /home/用户名/.pyenv/versions/3.6.9</p></blockquote><p>然后可以愉快的安装不同版本 python 和随意切换啦。</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的阿里云服务器中毒了，把这有趣的事情记录下来。</title>
      <link href="/s/linux-virus/"/>
      <url>/s/linux-virus/</url>
      
        <content type="html"><![CDATA[<p>自从用了 linux，由于 linux 用户量小又开源代码审查人多的特点，从而从来没为 linux 的安全担心过，这次算是第一次遭遇到病毒，值得记录下来。</p><a id="more"></a><h2 id="病毒的发现"><a class="markdownIt-Anchor" href="#病毒的发现"></a> 病毒的发现</h2><h3 id="发现"><a class="markdownIt-Anchor" href="#发现"></a> 发现</h3><p>偶然情况进了一下阿里云控制台，看了一眼监控，眼前的景象惊呆了。</p><p><img src="/img/ali-cpu.png" alt="" /></p><p>连续，一个月，CPU占用100%？我阿里云平时基本空闲，也只有我访问，也没什么复杂的计算，都是挂挂反向代理和做普通网站用，怎么也不可能出现这种现象。所以到这里基本确定，是有什么问题了，但是还没联想到病毒。</p><h3 id="怀疑"><a class="markdownIt-Anchor" href="#怀疑"></a> 怀疑</h3><p>直接登录阿里云，用 top 命令看了下，确实有个进程占 100% 的CPU，进程名是 .dhpcd 我还给看错了，第一反应看成 dhcpd ，以为是 dhcp 客户端出了什么故障，但前面为什么有个 点？而且 dhcp 客户端也没必要一直开着啊，就获取地址的时候用一下，难道是出了bug，陷入死循环？</p><p>又仔细看了下 top，用户名为 user ？？？？？更奇怪了，这个用户是我以前临时建立的，用来给一朋友登录玩 gcc 的，平时从来没用过。</p><h3 id="定位"><a class="markdownIt-Anchor" href="#定位"></a> 定位</h3><p>用 ps 看下这用户的所有进程信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep user</span><br></pre></td></tr></table></figure><p><img src="/img/vir-proc.png" alt="" /></p><p>在家目录的隐藏文件。直接去看看这个文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -al</span><br></pre></td></tr></table></figure><p><img src="/img/vir-file.png" alt="" /></p><p>这文件还挺大，大到 3 兆，看看它的类型。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file .dhpcd</span><br></pre></td></tr></table></figure><p><img src="/img/vir-type.png" alt="" /></p><p>这是编译好的二进制文件，排除了是我那朋友捣鬼。</p><p>把这文件上传到 <a href="https://www.virscan.org/" target="_blank" rel="noopener">virscan</a> 扫描一下吧。几分钟后看到<a href="http://r.virscan.org/language/zh-cn/report/f17b54910531cf6e2d98a963acadab48" target="_blank" rel="noopener">扫描结果</a>。</p><p><img src="/img/vir-scan-result.png" alt="" /></p><p><img src="/img/vir-scan-result-1.png" alt="" /><br /><img src="/img/vir-scan-result-2.png" alt="" /><br /><img src="/img/vir-scan-result-3.png" alt="" /><br /><img src="/img/vir-scan-result-4.png" alt="" /><br /><img src="/img/vir-scan-result-5.png" alt="" /></p><p>可以看到，出现 BitCoinMiner 的字样，让我几乎确定是比特币挖矿病毒。而且现象也符合，狂烧 CPU，就是在挖矿嘛。</p><h2 id="处理"><a class="markdownIt-Anchor" href="#处理"></a> 处理</h2><p>先 kill 掉它，然后设置它的权限为 000。把 user 这个用户也给删了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 000 .dhpcd</span><br></pre></td></tr></table></figure><p><img src="/img/vir-000.png" alt="" /></p><p>删除它吗？不删了，放那吧，等哪天想研究了再研究研究，把这小可爱留着做纪念。</p><p>但是是时候考虑安全问题了，为什么会中毒。再仔细想想，病毒只是感染了这一个用户，我这个用户的密码设置的 123456，所以很随意的就进来了，虽然没有 root 权限，没加入到 sudo 组，但是这种挖矿会占很大的资源，它可能已经挖了几个月了，而我今天才察觉到。</p><p>以后设置密码，无论是再简单的用户，再也不设这么简单的密码了，我密码最后头随便加个符号，都要好很多。</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于手机和电脑之间文字快速互通</title>
      <link href="/learn/qnote/"/>
      <url>/learn/qnote/</url>
      
        <content type="html"><![CDATA[<p>有时候在手机上搜到什么好代码好网址，想立刻转到电脑上用，发现有时候不怎么方便。有这几个方案：</p><ol><li>用通信软件，手机电脑同时启动QQ或微信，发送到电脑上。</li><li>用百度网盘或者github等服务互通。</li><li>用局域网软件，如feem、ftp等等。</li><li>用数据线，adb工具，访问手机储存。</li></ol><p>发现都有一定的不方便之处，要启动这么庞大的QQ，要同一局域网，要数据线。</p><p>既然咱们是做技术的，技术改变生活，让生活变得更方便。现在，是时候解决这个问题了。</p><a id="more"></a><h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2><p>由于我有个租的阿里云服务器，如果有这样一个轻量集软件，甚至不需要软件，只用浏览器，用一个网页就能实现电脑和手机互通，岂不是会非常迅速，对工作效率也会提升很多。</p><p>先找找有没有这方面的软件，闭源的商业软件要么有广告要么要登录很慢很复杂，不喜欢这样的。开源的软件也暂时找不到很方便的，希望有推荐。</p><p>应对自己这样的需求，我打算自己实现一个。</p><p>怎样的方案实现呢？想出几个备选方案：</p><ol><li><p>用 python 网络编程，tcp协议，服务端放服务器，客户端在任意终端。</p><p>麻烦之处在于在tcp协议之上得自己设计自己的协议，而且手机用python并不方便，显然实现起来比较麻烦成本比较高，不做这种重复造轮子的事情。</p></li><li><p>看来浏览器是个好东西，哪个终端设备都有浏览器，那么，用前端技术实现是不是最好的选择呢。</p><p>看起来是，用php编个后端在服务器上运行，打开浏览器就能记住笔记，然后后端把笔记记录到服务器中的某个文件里，任何浏览器访问的时候，后端读取这个文件前端处理显示出来。</p></li></ol><p>看来php这个方案是最方便的，就选它了。虽然前端开发经验比较少，仅限于知道http的get和post的请求，前端的html5的语法，css的基础知识，还有js基本怎么作用，后端大概怎么处理请求返回html页面的逻辑。</p><h2 id="设计"><a class="markdownIt-Anchor" href="#设计"></a> 设计</h2><p>既然是网页实现，那么在脑海里浮现了这样一个画面：</p><ol><li>一个多行文本框，有滚动条，可以输入任意长的文本。</li><li>两个按钮，一个按钮是提交，一个按钮是清空文本。</li><li>单击提交按钮后，会把文本框的内容通过post请求发送到服务器。</li><li>每次打开页面事，文本框内会自动显示服务器记录的文本。</li></ol><h2 id="预备的php知识"><a class="markdownIt-Anchor" href="#预备的php知识"></a> 预备的php知识</h2><p>由于没有php开发经验，只是知道php是个什么东西，只会php的hello world。没关系，先想想我需要什么，百度搜就是了。</p><ol><li><p>需要用php读写文件</p><p>百度一搜，搜到了 file_get_contents、fopen、fwrite、fclose 几个函数的语法，这不和众多编程语言一模一样的语法和参数嘛，这问题解决了。</p></li><li><p>变量的用法</p><p>编程免不了使用变量，哪怕再简单的程序。查了下，发现 php 的数据类型有字符串、整数、浮点数、逻辑、数组、对象，还是挺少的。这里主要用字符串。语法也很简单，不需要声明变量，每个变量前面都要加 $ ，无论是初始化赋值还是使用。</p></li><li><p>处理post请求</p><p>这个是重点，思路是前端的文本框用post发送到后端，后端得能收到内容并且存到文件。查了下，发现这个特殊变量 $_POST ，有点类似于python的字典用法，只需要指定前端传过来的键值，那么我就用 $_POST[“content”]。</p></li><li><p>编码解码</p><p>信息传递的过程中，由于我域名没有备案，用不了https，是http方式明文传输，中途被过滤关键字什么可能会降低传输速度，我想加密或者加一层编码，哪怕只用base64状况会好很多，那就选base64吧。</p><p>查到了这些函数：</p><ol><li>base64_encode 和 base64_decode</li><li>urlencode 和 urldecode</li><li>rawurlencode 和 rawurldecode</li></ol></li><li><p>语法</p><p>关于语法，在实验的过程中踩了很多坑，服务器总是返回 500 的错误码，检查发现都是漏分号。那么和 C++ 以及 java 的编程习惯一样，每个语句最后加分号。</p></li></ol><p>差不多就需要这么点东西了，前端如何处理编码解码呢，html实现不了，恐怕需要js，那么还得搜集一点js的函数和知识。</p><h2 id="预备的前端知识"><a class="markdownIt-Anchor" href="#预备的前端知识"></a> 预备的前端知识</h2><p>在前端的js和html，有需要实现编码解码，需要解码之后改变文本框的内容，post之前也得编码。</p><ol><li><p>多行文本框，随着窗口变化改变尺寸</p><p>用 textarea 标签，设置它及其 form 的样式 width</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">form</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">90%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">textarea</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">90%</span>;</span><br><span class="line">    <span class="attribute">overflow</span>:auto;</span><br><span class="line">    <span class="attribute">word-break</span>:break-all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>post 请求</p><p>设置 form 的 method 属性为 post</p></li><li><p>post 之后页面自动跳转回去</p><p>搜索查到这样的办法，在 head 标签里面加个 meta，表示一秒钟之后刷新到 /</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"refresh"</span> <span class="attr">content</span>=<span class="string">"1;url=/"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编码解码</p><p>查到了这些函数：</p><ol><li>encodeURI 和 decodeURI</li><li>encodeURIComponent 和 decodeURIComponent</li><li>window.btoa 和 window.atob</li></ol><p>在查询百度和反复用浏览器的控制台实验，终于弄清了他们的区别。</p><ol><li><p>改变文本框内容</p><ol><li><p>改变 textarea 的内容</p><p>document.getElementById(textarea的ID).value = 内容</p></li><li><p>改变 html 结构的内容</p><p>document.getElementById(标签的ID).innerText = 内容</p></li></ol></li></ol></li><li><p>适应手机端</p><p>搜索轻易查到在 head 标签里面加个 meta</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0, minimum-scale=0.5, maximum-scale=2.0, user-scalable=yes"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>##　逻辑设计</p><h3 id="前端"><a class="markdownIt-Anchor" href="#前端"></a> 前端</h3><ol><li>在打开页面之后，立刻执行js代码，把后端传输过来的编码过的字符串解码，然后把html内容设置成解码后的内容</li><li>在 post 请求之前，利用 input 标签的 onclick 属性提前执行一段js代码，把内容编码然后再 post</li></ol><h3 id="后端"><a class="markdownIt-Anchor" href="#后端"></a> 后端</h3><p>需要两个页面，一个是读取和编辑页面的 php，一个是处理 post 请求的页面 php，分别取名为 index.php 和 submit.php</p><ol><li><p><strong>index.php</strong></p><p>先读取文件，再编码文件，再显示到 testarea 的值里。</p></li><li><p><strong>submit.php</strong></p><p>先解码得到的内容，再把内容写入文件。</p></li></ol><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2><p>在经过一段时间的实验和调试后，index.php 和 submit.php 的代码基本完工，以下是简易的初始版本，后续可以随时改进。项目地址在 <a href="https://github.com/fkxxyz/qnote" target="_blank" rel="noopener">https://github.com/fkxxyz/qnote</a></p><h3 id="indexphp"><a class="markdownIt-Anchor" href="#indexphp"></a> index.php</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>fkxxyz<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0, minimum-scale=0.5, maximum-scale=2.0, user-scalable=yes"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">form &#123;</span><br><span class="line"><span class="css"><span class="selector-tag">width</span><span class="selector-pseudo">:90</span>%;</span></span><br><span class="line">&#125;</span><br><span class="line">textarea &#123;</span><br><span class="line"><span class="css"><span class="selector-tag">width</span><span class="selector-pseudo">:90</span>%;</span></span><br><span class="line"><span class="css"><span class="selector-tag">overflow</span><span class="selector-pseudo">:auto</span>;</span></span><br><span class="line"><span class="css"><span class="selector-tag">word-break</span><span class="selector-pseudo">:break-all</span>;</span></span><br><span class="line">&#125;</span><br><span class="line">input &#123;</span><br><span class="line"><span class="css"><span class="selector-tag">width</span><span class="selector-pseudo">:120px</span>;</span></span><br><span class="line"><span class="css"><span class="selector-tag">height</span><span class="selector-pseudo">:60px</span>;</span></span><br><span class="line"><span class="css"><span class="selector-tag">font-size</span><span class="selector-pseudo">:20px</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">"form"</span> <span class="attr">name</span>=<span class="string">"editform"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">action</span>=<span class="string">"submit.php"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">onclick</span>=<span class="string">"encode_texta()"</span> <span class="attr">value</span>=<span class="string">"提交"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"clear_texta()"</span> <span class="attr">value</span>=<span class="string">"清空"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">"texta"</span> <span class="attr">rows</span>=<span class="string">"20"</span> <span class="attr">name</span>=<span class="string">"content"</span>&gt;</span><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php">$file=<span class="string">"/srv/ftp/note.txt"</span>;</span></span><br><span class="line"><span class="php"><span class="keyword">echo</span> base64_encode(rawurlencode(base64_decode(file_get_contents($file))));</span></span><br><span class="line"><span class="php"><span class="meta">?&gt;</span></span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">t_encode</span><span class="params">(s)</span></span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">return</span> <span class="built_in">window</span>.btoa(<span class="built_in">encodeURIComponent</span>(s));</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">t_decode</span><span class="params">(s)</span></span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">return</span> <span class="built_in">decodeURIComponent</span>(<span class="built_in">window</span>.atob(s));</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">clear_texta</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">"texta"</span>).value = <span class="string">""</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">encode_texta</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">texta = <span class="built_in">document</span>.getElementById(<span class="string">"texta"</span>);</span></span><br><span class="line">texta.value = t_encode(texta.value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">decode_texta</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">texta = <span class="built_in">document</span>.getElementById(<span class="string">"texta"</span>);</span></span><br><span class="line">texta.value = t_decode(texta.value);</span><br><span class="line">&#125;</span><br><span class="line">decode_texta();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="submitphp"><a class="markdownIt-Anchor" href="#submitphp"></a> submit.php</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0, minimum-scale=0.5, maximum-scale=2.0, user-scalable=yes"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"refresh"</span> <span class="attr">content</span>=<span class="string">"1;url=/"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php">$file=<span class="string">"/srv/ftp/note.txt"</span>;</span></span><br><span class="line"><span class="php">$f = fopen($file, <span class="string">"w"</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"服务器出错！无法打开文件。"</span>);</span></span><br><span class="line"><span class="php">fwrite($f, base64_encode(rawurldecode(base64_decode($_POST[<span class="string">"content"</span>]))));</span></span><br><span class="line"><span class="php">fclose($f);</span></span><br><span class="line"><span class="php"><span class="keyword">echo</span> <span class="string">"&lt;h1&gt;提交成功&lt;/h1&gt;"</span>;</span></span><br><span class="line"><span class="php"><span class="keyword">echo</span> <span class="string">"&lt;div id=\"textd\"&gt;"</span>;</span></span><br><span class="line"><span class="php"><span class="keyword">echo</span> $_POST[<span class="string">"content"</span>];</span></span><br><span class="line"><span class="php"><span class="keyword">echo</span> <span class="string">"&lt;/div&gt;"</span></span></span><br><span class="line"><span class="php"><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">t_decode</span><span class="params">(s)</span></span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">return</span> <span class="built_in">decodeURIComponent</span>(<span class="built_in">window</span>.atob(s));</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">decode_textd</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">textd = <span class="built_in">document</span>.getElementById(<span class="string">"textd"</span>);</span></span><br><span class="line">textd.innerText = t_decode(textd.innerText);</span><br><span class="line">&#125;</span><br><span class="line">decode_textd();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="效果展示"><a class="markdownIt-Anchor" href="#效果展示"></a> 效果展示</h2><h3 id="电脑端"><a class="markdownIt-Anchor" href="#电脑端"></a> 电脑端</h3><p><img src="/img/qnote-1.png" alt="qnote-1"  /><img src="/img/qnote-2.png" alt="qnote-2"  /></p><h3 id="手机端"><a class="markdownIt-Anchor" href="#手机端"></a> 手机端</h3><img src="/img/qnote-3.png" style="zoom: 50%;" /><h2 id="电脑端更快速的处理"><a class="markdownIt-Anchor" href="#电脑端更快速的处理"></a> 电脑端更快速的处理</h2><p>在服务器端，我没有直接把内容直接放到文件里，而是加了层 base64 编码放进去。</p><p>因为考虑到，在 linux 端，我服务器开了 ftp，我可以不用打开浏览器也能快速连接到服务器获取内容，由于传输也没有加密，为了不以明文传输所以也 base64 一下。</p><p>以下命令快速获取服务器的笔记内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s ftp://地址/note.txt | base64 -d</span><br></pre></td></tr></table></figure><p>把它保存为脚本，一执行，就能在控制台里面看到内容，美滋滋。</p><p>同样的思路，能不能不打开浏览器也能 post 呢，一查果真容易实现，curl 就能发送 post 请求，连 pyhon 都免了！</p><p>以下命令快速记录笔记上传到服务器，返回错误代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -d "content=$(cat | base64)" http://地址/submit.php</span><br></pre></td></tr></table></figure><p>写成脚本吧，获取状态码，返回是否成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">code="$(curl -d "content=$(cat | base64)" -o /dev/null -w %&#123;http_code&#125; -s http://地址/submit.php)"</span><br><span class="line">echo</span><br><span class="line">if [ "$code" == "200" ]; then</span><br><span class="line">    echo "提交成功"</span><br><span class="line">else</span><br><span class="line">    echo "出错，http 状态码： $code"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>脚本执行后，可以输入任意文字，按 Ctrl + D 结束输入开始提交。</p><p>至此，大功告成。</p><p>再也不用启动 QQ微信什么的了，也不需要局域网软件了。只要能联网，任意地方都能快速笔记互通了。</p><h2 id="手机端-2"><a class="markdownIt-Anchor" href="#手机端-2"></a> 手机端</h2><p>手机端就更简单了，用的按卓手机，加上 chromium 浏览器，把我的服务器地址添加到桌面快捷方式，桌面上随时点开粘贴，然后提交。</p><h2 id="后续可能的改进"><a class="markdownIt-Anchor" href="#后续可能的改进"></a> 后续可能的改进</h2><ol><li><p>由于传输过程只是 base64 ，未加密，中途被拦截篡改或者泄露。</p><p>这个问题目前不需要解决，因为我个人不是什么重要机构信息没那么大的价值，也没有人恶意盯着陷害我，等以后有了安全需求再说。</p></li><li><p>谁都可以打开浏览器通过 http 协议访问我的服务器，只要知道我的服务器地址。</p><p>这个问题目前也不需要解决，因为我服务器私人用，也不会有谁故意捣乱。等到有这个需求再说，可以加个验证什么的。</p></li><li><p>有时候会有图片传输的需求，甚至文件传输的需求，一般都 ftp 或者在线私人网盘了，暂时也不需要。</p></li><li><p>美观。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 探究学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sed 命令从入门到精通</title>
      <link href="/c/sed/"/>
      <url>/c/sed/</url>
      
        <content type="html"><![CDATA[<p>作为 Linux 三剑客之一的 sed，shell 编程中掌握它是很有必要的。</p><p>本文用实验的方式循序渐进地学习 sed，可谓最科学的学习方式，一点一点遍历 sed 所有知识，实现真正的精通，同时还能作为速查。</p><p>快来动手跟着一起做吧！</p><a id="more"></a><h2 id="入门实践"><a class="markdownIt-Anchor" href="#入门实践"></a> 入门实践</h2><p>边实践边学习是真正掌握技能的唯一途径，下面从易到难来实验 sed 的各个命令。</p><h3 id="实验准备"><a class="markdownIt-Anchor" href="#实验准备"></a> 实验准备</h3><p>为了更好的实验，在临时目录建立一个文本文件以便测试。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /tmp</span><br><span class="line">mkdir a</span><br><span class="line">cd a</span><br></pre></td></tr></table></figure><p>创建一个文本文件 a.txt ，并写入十行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for a in $(seq 1 1 10); do echo line$a; done &gt; a.txt</span><br><span class="line">cat a.txt</span><br></pre></td></tr></table></figure><p>以下是 a.txt 的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">line3</span><br><span class="line">line4</span><br><span class="line">line5</span><br><span class="line">line6</span><br><span class="line">line7</span><br><span class="line">line8</span><br><span class="line">line9</span><br><span class="line">line10</span><br></pre></td></tr></table></figure><h3 id="开始实验"><a class="markdownIt-Anchor" href="#开始实验"></a> 开始实验</h3><h4 id="a-命令-添加新行"><a class="markdownIt-Anchor" href="#a-命令-添加新行"></a> a 命令 —— 添加新行</h4><p>在第 4 行的下面添加一行 newline</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sed '4anewline' a.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> 4 表示第 4 行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> a 表示添加</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> newline 表示要添加的行</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为了方便代码阅读，也可以加个<span class="string">'\'</span>或空格，写成如下等价形式</span></span><br><span class="line">sed '4a\newline' a.txt</span><br><span class="line">sed '4a newline' a.txt</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">line3</span><br><span class="line">line4</span><br><span class="line">newline</span><br><span class="line">line5</span><br><span class="line">line6</span><br><span class="line">line7</span><br><span class="line">line8</span><br><span class="line">line9</span><br><span class="line">line10</span><br></pre></td></tr></table></figure><p>也可以一次性添加多行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed '4anewline1\nnewline2' a.txt</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">line3</span><br><span class="line">line4</span><br><span class="line">newline1</span><br><span class="line">newline2</span><br><span class="line">line5</span><br><span class="line">line6</span><br><span class="line">line7</span><br><span class="line">line8</span><br><span class="line">line9</span><br><span class="line">line10</span><br></pre></td></tr></table></figure><h4 id="指定地址范围"><a class="markdownIt-Anchor" href="#指定地址范围"></a> 指定地址范围</h4><h5 id="范围分隔符"><a class="markdownIt-Anchor" href="#范围分隔符"></a> , —— 范围分隔符</h5><p>从第 4 行到第 8 行的所有行的下面分别添加一行 newline</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed '4,8anewline' a.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> 4,8 表示从第4行到第8行，用逗号隔开地址</span></span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">line3</span><br><span class="line">line4</span><br><span class="line">newline</span><br><span class="line">line5</span><br><span class="line">newline</span><br><span class="line">line6</span><br><span class="line">newline</span><br><span class="line">line7</span><br><span class="line">newline</span><br><span class="line">line8</span><br><span class="line">newline</span><br><span class="line">line9</span><br><span class="line">line10</span><br></pre></td></tr></table></figure><h5 id="到接下来几行"><a class="markdownIt-Anchor" href="#到接下来几行"></a> + —— 到接下来几行</h5><p>从第 4 行到其后两行的每一行分别添加一行 newline</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed '4,+2anewline' a.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> 4,+2 表示从第4行到第4+2行，等同于 4,6</span></span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">line3</span><br><span class="line">line4</span><br><span class="line">newline</span><br><span class="line">line5</span><br><span class="line">newline</span><br><span class="line">line6</span><br><span class="line">newline</span><br><span class="line">line7</span><br><span class="line">line8</span><br><span class="line">line9</span><br><span class="line">line10</span><br></pre></td></tr></table></figure><h5 id="~-倍数匹配"><a class="markdownIt-Anchor" href="#~-倍数匹配"></a> ~ —— 倍数匹配</h5><p>从第 5 行到第一次遇到的 4 的倍数行的每一行分别添加一行 newline</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed '5,~4anewline' a.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> 5,~4 相当于第 5 行到从第 5 行开始，遇到行号为 4 的倍数的行为止，等价于 5,8</span></span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">line3</span><br><span class="line">line4</span><br><span class="line">line5</span><br><span class="line">newline</span><br><span class="line">line6</span><br><span class="line">newline</span><br><span class="line">line7</span><br><span class="line">newline</span><br><span class="line">line8</span><br><span class="line">newline</span><br><span class="line">line9</span><br><span class="line">line10</span><br></pre></td></tr></table></figure><h5 id="~-步进"><a class="markdownIt-Anchor" href="#~-步进"></a> ~ —— 步进</h5><p>从第 5 行起，所有行号为 2 的倍数的行后面添加一行 newline</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed '5~2anewline' a.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> 5~2 表示从第 5 行起，所有行号为 2 的倍数的行</span></span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">line3</span><br><span class="line">line4</span><br><span class="line">line5</span><br><span class="line">newline</span><br><span class="line">line6</span><br><span class="line">line7</span><br><span class="line">newline</span><br><span class="line">line8</span><br><span class="line">line9</span><br><span class="line">newline</span><br><span class="line">line10</span><br></pre></td></tr></table></figure><h5 id="最后一行"><a class="markdownIt-Anchor" href="#最后一行"></a> $ —— 最后一行</h5><p>从第 4 行到最后一行的每一行分别添加一行 newline</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sed '4,$anewline' a.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> $ 表示最后一行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4,$ 表示从第 4 行到最后一行</span></span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">line3</span><br><span class="line">line4</span><br><span class="line">newline</span><br><span class="line">line5</span><br><span class="line">newline</span><br><span class="line">line6</span><br><span class="line">newline</span><br><span class="line">line7</span><br><span class="line">newline</span><br><span class="line">line8</span><br><span class="line">newline</span><br><span class="line">line9</span><br><span class="line">newline</span><br><span class="line">line10</span><br><span class="line">newline</span><br></pre></td></tr></table></figure><h5 id="范围取反"><a class="markdownIt-Anchor" href="#范围取反"></a> ! —— 范围取反</h5><p>从第 4 行到第 8 行之外的所有行后面添加一行 newline</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sed '4,8!anewline' a.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> ! 表示地址取反</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4,8! 表示从第 4 行到第 8 行之外的所有行</span></span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">line1</span><br><span class="line">newline</span><br><span class="line">line2</span><br><span class="line">newline</span><br><span class="line">line3</span><br><span class="line">newline</span><br><span class="line">line4</span><br><span class="line">line5</span><br><span class="line">line6</span><br><span class="line">line7</span><br><span class="line">line8</span><br><span class="line">line9</span><br><span class="line">newline</span><br><span class="line">line10</span><br><span class="line">newline</span><br></pre></td></tr></table></figure><h5 id="正则表达式范围"><a class="markdownIt-Anchor" href="#正则表达式范围"></a> // —— 正则表达式范围</h5><p>在匹配到 line4 的行后面添加一行 newline</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sed '/line4/anewline' a.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> /line4/ 表示匹配到 line4 的行</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 等价于</span></span><br><span class="line">sed '\?line4?anewline' a.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> 其中 ? 可以替换成任意字符</span></span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">line3</span><br><span class="line">line4</span><br><span class="line">newline</span><br><span class="line">line5</span><br><span class="line">line6</span><br><span class="line">line7</span><br><span class="line">line8</span><br><span class="line">line9</span><br><span class="line">line10</span><br></pre></td></tr></table></figure><p>在匹配到 line4 到第 6 行的行后面添加一行 newline</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed '/line4/,6anewline' a.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> /line4/,6 表示匹配到 line4 到第 6 行的行</span></span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">line3</span><br><span class="line">line4</span><br><span class="line">newline</span><br><span class="line">line5</span><br><span class="line">line6</span><br><span class="line">line7</span><br><span class="line">line8</span><br><span class="line">line9</span><br><span class="line">line10</span><br></pre></td></tr></table></figure><h4 id="i-命令-插入新行"><a class="markdownIt-Anchor" href="#i-命令-插入新行"></a> i 命令 —— 插入新行</h4><p>在第 4 行前插入一行 newline</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed '4inewline' a.txt</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">line3</span><br><span class="line">newline</span><br><span class="line">line4</span><br><span class="line">line5</span><br><span class="line">line6</span><br><span class="line">line7</span><br><span class="line">line8</span><br><span class="line">line9</span><br><span class="line">line10</span><br></pre></td></tr></table></figure><h4 id="d-命令-删除"><a class="markdownIt-Anchor" href="#d-命令-删除"></a> d 命令 —— 删除</h4><p>删除 4 到 8 行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed '4,8d' a.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> d 表示删除</span></span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">line3</span><br><span class="line">line9</span><br><span class="line">line10</span><br></pre></td></tr></table></figure><h4 id="c-命令-行替换"><a class="markdownIt-Anchor" href="#c-命令-行替换"></a> c 命令 —— 行替换</h4><p>将 4 到 8 行替换成 newline</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed '4,8cnewline' a.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> c 表示替换</span></span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">line3</span><br><span class="line">newline</span><br><span class="line">line9</span><br><span class="line">line10</span><br></pre></td></tr></table></figure><h4 id="p-命令-打印"><a class="markdownIt-Anchor" href="#p-命令-打印"></a> p 命令 —— 打印</h4><p>打印一遍 4 到 8 行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed '4,8p' a.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> p 表示打印</span></span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">line3</span><br><span class="line">line4</span><br><span class="line">line4</span><br><span class="line">line5</span><br><span class="line">line5</span><br><span class="line">line6</span><br><span class="line">line6</span><br><span class="line">line7</span><br><span class="line">line7</span><br><span class="line">line8</span><br><span class="line">line8</span><br><span class="line">line9</span><br><span class="line">line10</span><br></pre></td></tr></table></figure><p>只打印 4 到 8 行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -n '4,8p' a.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> -n 表示不打印原文</span></span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">line4</span><br><span class="line">line5</span><br><span class="line">line6</span><br><span class="line">line7</span><br><span class="line">line8</span><br></pre></td></tr></table></figure><p>从匹配到 “line4” 的行打印到匹配到 “ne6” 的行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -n '/line4/,/e6/p' a.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> 本例配合地址可灵活运用</span></span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">line4</span><br><span class="line">line5</span><br><span class="line">line6</span><br></pre></td></tr></table></figure><h4 id="命令-打印行号"><a class="markdownIt-Anchor" href="#命令-打印行号"></a> = 命令 —— 打印行号</h4><p>从匹配到 “line4” 的行打印到匹配到 “ne6” 的行号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -n '/line4/,/e6/=' a.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> = 表示打印那一行的行号</span></span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td></tr></table></figure><h4 id="s-命令-正则替换"><a class="markdownIt-Anchor" href="#s-命令-正则替换"></a> s 命令 —— 正则替换</h4><p>将第 4 行到第 8 行的 ne 替换成 on</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sed '4,8s/ne/on/' a.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> s 表示替换</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     格式为： s/正则表达式/要替换的内容/</span></span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">line3</span><br><span class="line">lion4</span><br><span class="line">lion5</span><br><span class="line">lion6</span><br><span class="line">lion7</span><br><span class="line">lion8</span><br><span class="line">line9</span><br><span class="line">line10</span><br></pre></td></tr></table></figure><p>s 命令最后跟个 g 表示替换该行所有匹配</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 'abcdabcd\nbcdebcde' | sed 's/b/x/g'</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">axcdaxcd</span><br><span class="line">xcdexcde</span><br></pre></td></tr></table></figure><p>而不加 g 的 s 只能替换每一行匹配到的第一个</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 'abcdabcd\nbcdebcde' | sed 's/b/x/'</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">axcdabcd</span><br><span class="line">xcdebcde</span><br></pre></td></tr></table></figure><p>正则表达式的实例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sed '4,8s/\(line\)\([[:digit:]]\+\)/\2 - \1/' a.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> 4,8 表示从第 4 行到第 8 行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> \(line\)\([[:digit:]]\+\) 是正则表达式</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> \1 表示正则表达式中第一个括号匹配的结果</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> \2 表示正则表达式中第二个括号匹配的结果</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以加 -r 参数开启扩展正则表达式，写成等价形式</span></span><br><span class="line">sed -r '4,8s/(line)([[:digit:]]+)/\2 - \1/' a.txt</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">line3</span><br><span class="line">4 - line</span><br><span class="line">5 - line</span><br><span class="line">6 - line</span><br><span class="line">7 - line</span><br><span class="line">8 - line</span><br><span class="line">line9</span><br><span class="line">line10</span><br></pre></td></tr></table></figure><h4 id="y-命令-字符映射替换"><a class="markdownIt-Anchor" href="#y-命令-字符映射替换"></a> y 命令 —— 字符映射替换</h4><p>将第 4 行到第 5 行按照字符映射 {e,i,l,n} -&gt; {o,c,e,h} 进行替换</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed '4,5y/eiln/oceh/' a.txt</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">line3</span><br><span class="line">echo4</span><br><span class="line">echo5</span><br><span class="line">line6</span><br><span class="line">line7</span><br><span class="line">line8</span><br><span class="line">line9</span><br><span class="line">line10</span><br></pre></td></tr></table></figure><h4 id="r-命令-行替换为文件内容"><a class="markdownIt-Anchor" href="#r-命令-行替换为文件内容"></a> r 命令 —— 行替换为文件内容</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 先写入一个 b.txt 文件作为测试文件</span></span><br><span class="line">echo 'aaa\nbbb' &gt; b.txt</span><br><span class="line"></span><br><span class="line">sed '4,5rb.txt' a.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> r 表示以后面作为文件名读取文件内容进行替换</span></span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">line3</span><br><span class="line">line4</span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">line5</span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">line6</span><br><span class="line">line7</span><br><span class="line">line8</span><br><span class="line">line9</span><br><span class="line">line10</span><br></pre></td></tr></table></figure><h4 id="脚本块"><a class="markdownIt-Anchor" href="#脚本块"></a> {} —— 脚本块</h4><p>在大括号内用分号隔开命令，可以实现执行多个命令</p><p>打印 3 到 4 行和 7 到 8 行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sed -n '&#123;3,4p;7,8p&#125;' a.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 最外层大括号可省略</span></span><br><span class="line">sed -n '3,4p;7,8p' a.txt</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">line3</span><br><span class="line">line4</span><br><span class="line">line7</span><br><span class="line">line8</span><br></pre></td></tr></table></figure><p>如果每个命令的地址相同，那么也可以类似于像分配律一样的语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sed -n '4&#123;p;=&#125;' a.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 等价于</span></span><br><span class="line">sed -n '&#123;4p;4=&#125;' a.txt</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">line4</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>连 s 命令都能包含，体会到替换前和替换后的不同</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n '4&#123;p;s/ne/on/;p;=&#125;' a.txt</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">line4</span><br><span class="line">lion4</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>大括号可以嵌套</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n '&#123;4&#123;p;=&#125;;8&#123;=;p&#125;&#125;' a.txt</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">line4</span><br><span class="line">4</span><br><span class="line">8</span><br><span class="line">line8</span><br></pre></td></tr></table></figure><p>如果嵌套时，地址不同，则会取交集</p><ol><li><pre class="highlight"><code class="shell">sed -n '3,7{4,5p}' a.txt<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">输出结果</span><br></pre></td></tr></table></figure>line4line5<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. &#96;&#96;&#96;shell</span><br><span class="line">   sed -n &#39;4,7&#123;3,6p&#125;&#39; a.txt</span><br></pre></td></tr></table></figure>输出结果<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">line4</span><br><span class="line">line5</span><br><span class="line">line6</span><br></pre></td></tr></table></figure></code></pre></li></ol><h4 id="hhggx-空间交换相关"><a class="markdownIt-Anchor" href="#hhggx-空间交换相关"></a> h,H,g,G,x —— 空间交换相关</h4><p>首先需要弄懂两个概念：模式空间、保持空间。</p><p>**模式空间：**sed 命令默认是一行一行处理的，每读取到一行，会放到模式空间里，然后执行脚本来处理模式空间的内容，处理完后会清空模式空间，并且读取下一行继续处理，如此循环直到行尾。模式空间相当于专门用于 sed 处理的字符串缓冲区。</p><p>**保持空间：**默认的 sed 是不会操作保持空间的，保持空间是专门为用户提供的空间，这几个命令可以操作保持空间，来实现更复杂的功能。</p><blockquote><p>**h：**把模式空间内容覆盖到保持空间中<br />**H：**把模式空间内容追加到保持空间中<br />**g：**把保持空间内容覆盖到模式空间中<br />**G：**把保持空间内容追加到模式空间中<br />**x：**交换模式空间与保持空间的内容</p></blockquote><p>将第 4 行和第 6 行复制到第 8 行后面。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sed '&#123;4h;6H;8G&#125;' a.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4h 表示将第 4 行放入保持空间</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 6H 表示将第 6 行加入保持空间</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 8G 表示将保持空间内容追加到模式空间</span></span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">line3</span><br><span class="line">line4</span><br><span class="line">line5</span><br><span class="line">line6</span><br><span class="line">line7</span><br><span class="line">line8</span><br><span class="line">line4</span><br><span class="line">line6</span><br><span class="line">line9</span><br><span class="line">line10</span><br></pre></td></tr></table></figure><h4 id="nnpd-模式空间操作"><a class="markdownIt-Anchor" href="#nnpd-模式空间操作"></a> n,N,P,D —— 模式空间操作</h4><p>有了模式空间的概念后，可以重新理解一下前面 p、d、n 等命令的本质。</p><blockquote><p>**p：**打印当前模式空间所有内容，追加到默认输出之后。</p><p>**P：**打印当前模式空间开端至\n的内容，并追加到默认输出之前。Sed并不对每行末尾\n进行处理，但是对N命令追加的行间\n进行处理，因为此时sed将两行看做一行。</p><p>**n：**命令简单来说就是提前读取下一行，覆盖模型空间前一行，然后执行后续命令。然后再读取新行，对新读取的内容重头执行sed。</p><p>**N：**命令简单来说就是追加下一行到模式空间，同时将两行看做一行，但是两行之间依然含有\n换行符，然后执行后续命令。然后再读取新行，对新读取的内容重头执行sed。此时，新读取的行会覆盖之前的行（之前的两行已经合并为一行）。</p><p>**d：**命令是删除当前模式空间内容（不再传至标准输出）， 并放弃之后的命令，并对新读取的内容，重头执行sed。</p><p>**D：**命令是删除当前模式空间开端至\n的内容（不在传至标准输出）， 放弃之后的命令，但是对剩余模式空间重新执行sed。</p></blockquote><p>删除匹配 line4 行的下一行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed '/line4/&#123;n;d&#125;' a.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> 操作到第 4 行时，提前读取第 5 行并删掉。</span></span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">line3</span><br><span class="line">line4</span><br><span class="line">line6</span><br><span class="line">line7</span><br><span class="line">line8</span><br><span class="line">line9</span><br><span class="line">line10</span><br></pre></td></tr></table></figure><p>打印偶数行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sed -n '&#123;n;p&#125;' a.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> n 命令表示操作每一行时，读取下一行，覆盖掉已经读取的这一行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> p 表示打印出来</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 每次循环时，模式空间中，奇数行全部被偶数行覆盖</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 打印偶数行也可以用步进地址实现</span></span><br><span class="line">sed -n '2~2p' a.txt</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">line2</span><br><span class="line">line4</span><br><span class="line">line6</span><br><span class="line">line8</span><br><span class="line">line10</span><br></pre></td></tr></table></figure><p>删除匹配到 line4 行和下一行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed '/line4/&#123;N;d&#125;' a.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> 操作到第 4 行时，提前读取第 5 行追加到模式空间，然后两行一起删掉。</span></span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">line3</span><br><span class="line">line6</span><br><span class="line">line7</span><br><span class="line">line8</span><br><span class="line">line9</span><br><span class="line">line10</span><br></pre></td></tr></table></figure><p>打印奇数行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sed –n '$!N;P' a.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> 除了最后一行之外所有行，都提前读取下一行追加到模式空间，然后打印追加前的第一行，最后一行单独输出</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 打印奇数行也可以用步进地址实现</span></span><br><span class="line">sed -n '1~2p' a.txt</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">line1</span><br><span class="line">line3</span><br><span class="line">line5</span><br><span class="line">line7</span><br><span class="line">line9</span><br></pre></td></tr></table></figure><p>每次提前读取三行，输出第一行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n '&#123;N;N;P&#125;' a.txt</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">line1</span><br><span class="line">line4</span><br><span class="line">line7</span><br></pre></td></tr></table></figure><h4 id="b-标签跳转"><a class="markdownIt-Anchor" href="#b-标签跳转"></a> b —— 标签跳转</h4><p>**b：**跳转到用冒号开头表示的标签</p><p>用标签跳转的方式实现：将除了匹配 line4 的行其它行的 ne 换成 on</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sed '/line4/bend;s/ne/on/;:end' a.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> 匹配到 line4 时，会执行 b 命令，跳转到最后的 :end 标签，也就相当于跳过了替换命令</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果标签在前可能造成死循环，需要注意指定行</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当标签在最后时，可以省略，而且当 b 命令指定的标签不存在时，会自动跳转到最后</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 所以可简写成</span></span><br><span class="line">sed '/line4/b;s/ne/on/' a.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当然，可以用前面的地址范围取反来实现</span></span><br><span class="line">sed '/line4/!s/ne/on/' a.txt</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">lion1</span><br><span class="line">lion2</span><br><span class="line">lion3</span><br><span class="line">line4</span><br><span class="line">lion5</span><br><span class="line">lion6</span><br><span class="line">lion7</span><br><span class="line">lion8</span><br><span class="line">lion9</span><br><span class="line">lion10</span><br></pre></td></tr></table></figure><h4 id="t-条件标签跳转"><a class="markdownIt-Anchor" href="#t-条件标签跳转"></a> t —— 条件标签跳转</h4><p>**t：**如果前一条命令执行成功，则跳转到用冒号开头表示的标签。</p><p>用条件标签跳转的方式实现：将除了匹配 line4 的行其它行的 ne 换成 on，4换成 F</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sed 's/4/F/;tend;s/ne/on/;:end' a.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当标签在最后时，可以省略，而且当 b 命令指定的标签不存在时，会自动跳转到最后</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 所以可简写成</span></span><br><span class="line">sed 's/4/F/;t;s/ne/on/' a.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当然，可以用前面的地址范围取反来实现</span></span><br><span class="line">sed '/4/!s/ne/on/;/4/s/4/F/' a.txt</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">lion1</span><br><span class="line">lion2</span><br><span class="line">lion3</span><br><span class="line">lineF</span><br><span class="line">lion5</span><br><span class="line">lion6</span><br><span class="line">lion7</span><br><span class="line">lion8</span><br><span class="line">lion9</span><br><span class="line">lion10</span><br></pre></td></tr></table></figure><h2 id="速查"><a class="markdownIt-Anchor" href="#速查"></a> 速查</h2><p><em>以下内容使用谷歌翻译自 <a href="https://linux.die.net/man/1/sed" target="_blank" rel="noopener">sed(1) - Linux man page</a></em> 以及 sed --help，可供参考。</p><h3 id="名称"><a class="markdownIt-Anchor" href="#名称"></a> 名称</h3><p>sed - 流编辑器，用于过滤和转换文本</p><h3 id="语法"><a class="markdownIt-Anchor" href="#语法"></a> 语法</h3><p>sed [可选参数]… {脚本} [输入文件]…</p><p>如果未提供-e，-expression，-f或–file选项，则将第一个非可选参数用作要解释的sed脚本。 其余所有参数均为输入文件的名称； 如果未指定输入文件，那么将读取标准输入。</p><h3 id="描述"><a class="markdownIt-Anchor" href="#描述"></a> 描述</h3><p>Sed是流编辑器。 流编辑器用于对输入流（文件或来自管道的输入）执行基本的文本转换。 尽管在某种程度上类似于允许脚本编辑（例如ed）的编辑器，但sed通过仅对输入进行一次传递来工作，因此效率更高。 但是sed能够过滤管道中的文本，这使其与其他类型的编辑器特别有区别。</p><h4 id="-n-quiet-silent"><a class="markdownIt-Anchor" href="#-n-quiet-silent"></a> -n, --quiet, --silent</h4><p>禁止自动打印模式空间</p><h4 id="-e-脚本-expression脚本"><a class="markdownIt-Anchor" href="#-e-脚本-expression脚本"></a> -e 脚本, --expression=脚本</h4><p>添加“脚本”到程序的运行列表</p><h4 id="-f-脚本文件-file脚本文件"><a class="markdownIt-Anchor" href="#-f-脚本文件-file脚本文件"></a> -f 脚本文件, --file=脚本文件</h4><p>添加“脚本文件”到程序的运行列表</p><h4 id="follow-symlinks"><a class="markdownIt-Anchor" href="#follow-symlinks"></a> –follow-symlinks</h4><p>直接修改文件时跟随符号链接； 硬链接仍然会断开。</p><h4 id="-i扩展名-in-place扩展名"><a class="markdownIt-Anchor" href="#-i扩展名-in-place扩展名"></a> -i[扩展名], --in-place[=扩展名]</h4><p>直接修改文件（如果指定扩展名则备份文件）</p><h4 id="-c-copy"><a class="markdownIt-Anchor" href="#-c-copy"></a> -c, --copy</h4><p>在 -i 模式下直接修改文件且备份时，使用复制操作而不是重命名。 尽管这样做可以避免断开链接（符号链接或硬链接），但最终的编辑操作不是原子的。 这很少是理想的模式。 --follow-symlinks通常就足够了，并且更快，更安全。</p><h4 id="-l-n-line-lengthn"><a class="markdownIt-Anchor" href="#-l-n-line-lengthn"></a> -l N, --line-length=N</h4><p>指定“l”命令的换行期望长度</p><h4 id="posix"><a class="markdownIt-Anchor" href="#posix"></a> –posix</h4><p>关闭所有 GNU 扩展</p><h4 id="-e-r-regexp-extended"><a class="markdownIt-Anchor" href="#-e-r-regexp-extended"></a> -E, -r, --regexp-extended</h4><p>在脚本中使用扩展正则表达式（为保证可移植性使用 POSIX -E）。</p><h4 id="-s-separate"><a class="markdownIt-Anchor" href="#-s-separate"></a> -s, --separate</h4><p>将输入文件视为各个独立的文件而不是单个长的连续输入流</p><h4 id="-u-unbuffered"><a class="markdownIt-Anchor" href="#-u-unbuffered"></a> -u, --unbuffered</h4><p>从输入文件读取最少的数据，更频繁的刷新输出</p><h4 id="help"><a class="markdownIt-Anchor" href="#help"></a> –help</h4><p>打印帮助并退出</p><h4 id="version"><a class="markdownIt-Anchor" href="#version"></a> –version</h4><p>输出版本信息并退出</p><h3 id="命令语法"><a class="markdownIt-Anchor" href="#命令语法"></a> 命令语法</h3><p>这只是sed命令的简要提要，以提示那些已经知道sed的人。 必须参考其他文档（例如texinfo文档）以获取更完整的描述。</p><h4 id="标签"><a class="markdownIt-Anchor" href="#标签"></a> : 标签</h4><p><strong>b</strong> 和 <strong>t</strong> 命令的标签</p><h4 id="注释"><a class="markdownIt-Anchor" href="#注释"></a> # 注释</h4><p>注释会一直延伸到下一个换行符（或**-e **脚本片段的末尾）。</p><h4 id=""><a class="markdownIt-Anchor" href="#"></a> }</h4><p>关闭 {}块 的括号的右半括号</p><h4 id="-2"><a class="markdownIt-Anchor" href="#-2"></a> =</h4><p>打印当前行号</p><h4 id="a-文本"><a class="markdownIt-Anchor" href="#a-文本"></a> a 文本</h4><p>在模式空间后追加文本，该文本的每个嵌入换行符前都有一个反斜杠。</p><h4 id="i-文本"><a class="markdownIt-Anchor" href="#i-文本"></a> i 文本</h4><p>在模式空间前插入文本，该文本的每个嵌入换行符前都有一个反斜杠。</p><h4 id="q-退出代码"><a class="markdownIt-Anchor" href="#q-退出代码"></a> q [退出代码]</h4><p>立即退出 sed 脚本而不处理任何其他输入，除非如果未禁用自动打印，将打印当前图案空间。 退出代码参数是GNU扩展。</p><h4 id="q-退出代码-2"><a class="markdownIt-Anchor" href="#q-退出代码-2"></a> Q [退出代码]</h4><p>立即退出 sed 脚本，而不处理更多输入。 这是一个GNU扩展。</p><h4 id="r-文件名"><a class="markdownIt-Anchor" href="#r-文件名"></a> r 文件名</h4><p>从文件中读取的文本追加到模式空间中。</p><h4 id="r-文件名-2"><a class="markdownIt-Anchor" href="#r-文件名-2"></a> R 文件名</h4><p>从文件中读取的文本追加到模式空间中。 每次调用该命令都会从文件中读取一行。这是一个GNU扩展。</p><h4 id="-3"><a class="markdownIt-Anchor" href="#-3"></a> {</h4><p>启动 {}块 的括号的左半括号</p><h4 id="b-标签"><a class="markdownIt-Anchor" href="#b-标签"></a> b [标签]</h4><p>跳转到标签； 如果省略了标签参数，则跳转到脚本结尾。</p><h4 id="t-标签"><a class="markdownIt-Anchor" href="#t-标签"></a> t [标签]</h4><p>如果上一条读取的输入行被 s/// 命令替换成功，则跳转至标签 ; 如果省略标签，则跳转到脚本结尾。</p><h4 id="t-标签-2"><a class="markdownIt-Anchor" href="#t-标签-2"></a> T [标签]</h4><p>如果上一条读取的输入行没有被 s/// 命令替换成功，则跳转至标签 ; 如果省略标签，则跳转到脚本结尾。这是一个GNU扩展。</p><h4 id="c-文本"><a class="markdownIt-Anchor" href="#c-文本"></a> c 文本</h4><p>将所选行替换为文本，该文本的每个嵌入换行符前都有一个反斜杠。</p><h4 id="d"><a class="markdownIt-Anchor" href="#d"></a> d</h4><p>删除模式空间。 开始下一个循环。</p><h4 id="d-2"><a class="markdownIt-Anchor" href="#d-2"></a> D</h4><p>删除模式空间中的第一个嵌入的行。 从下一个循环开始，但是如果模式空间中仍有数据，则跳过从输入中读取的操作。</p><h4 id="h-h"><a class="markdownIt-Anchor" href="#h-h"></a> h H</h4><p>复制/追加模式空间到保持空间。</p><h4 id="g-g"><a class="markdownIt-Anchor" href="#g-g"></a> g G</h4><p>复制/追加保持空间到模式空间。</p><h4 id="x"><a class="markdownIt-Anchor" href="#x"></a> x</h4><p>交换保持空间和模式空间的内容。</p><h4 id="l"><a class="markdownIt-Anchor" href="#l"></a> l</h4><p>以“视觉清晰”的形式列出当前行。</p><h4 id="l-宽度"><a class="markdownIt-Anchor" href="#l-宽度"></a> l 宽度</h4><p>以“视觉清晰”的形式列出当前行，并以根据指定宽度的字符将其断开。 这是一个GNU扩展。</p><h4 id="n-n"><a class="markdownIt-Anchor" href="#n-n"></a> n N</h4><p>将输入的下一行读取/追加到模式空间。</p><h4 id="p"><a class="markdownIt-Anchor" href="#p"></a> p</h4><p>打印当前模式空间</p><h4 id="p-2"><a class="markdownIt-Anchor" href="#p-2"></a> P</h4><p>打印当前模式空间直到第一个嵌入式换行符。</p><h4 id="s正则表达式替代串"><a class="markdownIt-Anchor" href="#s正则表达式替代串"></a> s/正则表达式/替代串/</h4><p>尝试将正则表达式与模式空间进行匹配。 如果成功，则用替代串/替换该部分。替代串可以包含特殊字符 “&amp;” 来表示匹配的模式空间部分，而特殊转义 \1 到 \9 则表示正则表达式中的相应匹配子表达式。</p><h4 id="w-文件名"><a class="markdownIt-Anchor" href="#w-文件名"></a> w 文件名</h4><p>将当前模式空间写入文件。</p><h4 id="w-文件名-2"><a class="markdownIt-Anchor" href="#w-文件名-2"></a> W 文件名</h4><p>将当前模式空间的第一行写入文件。 这是一个GNU扩展。</p><h4 id="y源串目标串"><a class="markdownIt-Anchor" href="#y源串目标串"></a> y/源串/目标串/</h4><p>将模式空间中出现在源串中的字符翻译成目标串中的相应字符。</p><h3 id="地址"><a class="markdownIt-Anchor" href="#地址"></a> 地址</h3><p>sed命令可以不带地址，在这种情况下，将对所有输入行执行该命令。 具有一个地址，在这种情况下，该命令仅对与该地址匹配的输入行执行； 或使用两个地址，在这种情况下，将对所有输入行执行命令，这些输入行与从第一个地址开始一直延伸到第二个地址的所有行包括在内。 有关地址范围的三点注意事项：语法为“地址1,地址2”（即地址用逗号分隔）； 即使地址2选择了较早的行，也将始终接受与地址匹配的行； 如果地址2是正则表达式，则不会针对地址1匹配的行进行测试。</p><p>在地址（或地址范围）之后，在命令之前，! 可以插入，它指定仅当地址（或地址范围）不匹配时才执行命令。</p><h4 id="数字"><a class="markdownIt-Anchor" href="#数字"></a> 数字</h4><p>仅匹配指定的数字行。</p><h4 id="首行~步进"><a class="markdownIt-Anchor" href="#首行~步进"></a> 首行~步进</h4><p>匹配从首行开始的每个相隔步进的行。 例如，“ sed -n 1<sub>2p”将打印输入流中的所有奇数行，并且地址2</sub>5将与第二行开始的每第五行匹配。首行可以为零； 在这种情况下，sed 的操作就好像等于步进。 （这是一个扩展。）</p><h4 id="-4"><a class="markdownIt-Anchor" href="#-4"></a> $</h4><p>表示最后一行。</p><h4 id="正则表达式"><a class="markdownIt-Anchor" href="#正则表达式"></a> /正则表达式/</h4><p>匹配正则表达式的行。</p><h4 id="c正则表达式c"><a class="markdownIt-Anchor" href="#c正则表达式c"></a> \c正则表达式c</h4><p>匹配正则表达式的行。c 可以是任何字符。</p><h3 id="gnu-sed-还支持一些特殊的2地址形式"><a class="markdownIt-Anchor" href="#gnu-sed-还支持一些特殊的2地址形式"></a> GNU sed 还支持一些特殊的2地址形式</h3><h4 id="0地址2"><a class="markdownIt-Anchor" href="#0地址2"></a> 0,地址2</h4><p>从“匹配的第一个地址”状态开始，直到找到地址2。 这类似于“1,地址2”，不同之处在于，如果地址2与输入的第一行匹配，则“0,地址2”形式将在其范围的末尾，而“1,地址2”形式仍为在其范围的开始。仅当地址2为正则表达式时有效。</p><h4 id="地址1n"><a class="markdownIt-Anchor" href="#地址1n"></a> 地址1,+N</h4><p>将匹配地址1和地址1之后的 N 行。</p><h4 id="地址1~n"><a class="markdownIt-Anchor" href="#地址1~n"></a> 地址1,~N</h4><p>将匹配地址1和地址1之后的行，直到输入行号是 N 的倍数的下一行。</p><h3 id="正则表达式-2"><a class="markdownIt-Anchor" href="#正则表达式-2"></a> 正则表达式</h3><p>本来应该支持POSIX.2 BRE，但是由于性能问题，它们并不完全支持。 正则表达式中的 \n 序列与换行符匹配，对于 \a，\t 和其他序列也是如此。</p><h2 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h2><ol><li><a href="https://linux.die.net/man/1/sed" target="_blank" rel="noopener">sed(1) - Linux man page</a></li><li><a href="https://www.runoob.com/linux/linux-comm-sed.html" target="_blank" rel="noopener">菜鸟教程 —— Linux sed 命令</a></li><li><a href="https://www.cnblogs.com/liwei0526vip/p/5644163.html" target="_blank" rel="noopener">肖邦linux —— sed入门详解教程</a></li><li><a href="https://www.cnblogs.com/irockcode/p/8018575.html" target="_blank" rel="noopener">DataCareer —— Sed命令n，N，d，D，p，P，h，H，g，G，x解析</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
            <tag> sed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次 excel 文档的密码破解的探索</title>
      <link href="/learn/excel-crack/"/>
      <url>/learn/excel-crack/</url>
      
        <content type="html"><![CDATA[<p>周末的时候，有个以前的同学说自己的 excel 密码忘记，所以找我帮忙看有没有办法破解开来。</p><p>由于之前从来没接触过这样的实战，对加密解密仅仅只是了解的概念，基本都是理论知识，于是开始了实战探索之路。</p><a id="more"></a><h2 id="探索之路"><a class="markdownIt-Anchor" href="#探索之路"></a> 探索之路</h2><h3 id="已有知识"><a class="markdownIt-Anchor" href="#已有知识"></a> 已有知识</h3><p>在印象中，几年前下载过这样的破解 office 密码的软件，名字是 Advanced Office Password Recovery，还接触过很多压缩包密码破解，听说过 wifi 密码破解等等。</p><p>根据所学过的知识，我将密码破解分为三类：</p><ol><li>**暴力破解：**这种方式是利用计算机高计算速度的特性，让程序按一定的规律或规则，一个一个试密码，直到试出来为止。</li><li>**逆向算法以及哈希碰撞：**一般的加密算法是不可能那么轻易可逆的，也没那么容易碰撞，一般只有顶尖的数学家密码学家牛人才能探索出这种算法，当今普遍采用的算法一般都是还没被探索出碰撞的。</li><li><strong>伪加密直接清除密码</strong>：确切的说只对没有加密的文档管用，可以说是伪加密，仅仅是软件让你输入密码数对了才能访问到真正数据，而真正数据并未加密，严格说不算一种破解方法，局限性很大。</li></ol><p>由于她用的是 excel 2013 的加密文档，然后去网上搜索 excel 2013 的解密，无一例外都是暴力破解的方式，和我想的一样，微软不可能傻到伪加密，也不可能用一些已经被破解了的不安全的算法，基本能确定只有暴力破解这一种方法。</p><h3 id="软件尝试"><a class="markdownIt-Anchor" href="#软件尝试"></a> 软件尝试</h3><p>这次破解密码，我首先尝试的是 Advanced Office Password Recovery，由于用的 archlinux 系统，直接使用 wine 来安装运行，启动成功。</p><p>先看看这款软件能否行的通吧，首先，我打开我电脑里已装好的 excel 2007，然后里面随便写点东西，然后加密保存，密码设为 qwertyuio，然后新建一个字典，随便输几行，并且把真实密码也放进去，打开这软件，加载字典，开始搜索，果然，秒出结果。证明了这软件还是行的通的。</p><h3 id="字典构造"><a class="markdownIt-Anchor" href="#字典构造"></a> 字典构造</h3><p>再搜集线索，这样可以缩小搜索范围，得知她设的是一句类似于“工作让我想死”的每个字的首字母组合，长度在 6～9 位，那么接下来让她想尽可能多的词语。比如“让人”、“令人”、“心烦”等等类似的词，首字母记下来。</p><p>然后再仔细想想其中的规律，”gz“肯定是开头两位，中间的词语不确定，有几个备选词语，结尾词语也不确定，同样几个备选，我设想这句话可以分为几个部分，每个部分都是一个词语，把每一部分写成一行，每一行里用逗号隔开词语的所有可能性，然后写了如下 txt 文档。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gz</span><br><span class="line">,zs,zd</span><br><span class="line">l,s,r</span><br><span class="line">w,r</span><br><span class="line">xf,xs</span><br></pre></td></tr></table></figure><p>其中第二行逗号开头表示可缺省，那么一共有 1*3*3*2*2=36 种情况，虽然手动一个一个试是可以试完的，但是设想到万一都不对肯定要考虑别的词语，倒不如编个程序，根据上述 txt 文档来生成一个包含所有情况的字典，然后就可以放到破解软件里去跑，然后就可以随时加词语再生成字典再去跑。</p><p>说动手就动手，十分钟后，一个简易的 python 程序诞生。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'a.txt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    r=f.read().strip()</span><br><span class="line"></span><br><span class="line">lines=r.split(<span class="string">'\n'</span>)</span><br><span class="line">words=[]</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">words.append(line.split(<span class="string">','</span>))</span><br><span class="line"></span><br><span class="line">l=len(words)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rec</span><span class="params">(s,i)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> i==l:</span><br><span class="line">        print(s)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> words[i]:</span><br><span class="line">        rec(s+j,i+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">rec(<span class="string">''</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>思路也很清晰，固定读取 a.txt，用一个递归函数，一行一行的遍历，达到最深（最后一行）时打印出来此情况并且回溯。</p><h3 id="开始破解"><a class="markdownIt-Anchor" href="#开始破解"></a> 开始破解</h3><p>把程序生成的字典放到软件里去跑，立马出结果，说密码未找到，说明 36 种情况都不是。</p><p>于是把思路和规则告诉她，让她加词语，加情况。通过实验得知，我的电脑每秒钟能试 400 次密码。</p><p>然后加了几个词语继续试。</p><p>120种情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gz</span><br><span class="line">,zs,zd,ztm</span><br><span class="line">l,s,r</span><br><span class="line">w,r</span><br><span class="line">xs,xf,fs,ns,ty</span><br></pre></td></tr></table></figure><p>400种情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gz</span><br><span class="line">,z,t,y,u,I,o,p,g,h,j,k,l,v,b,n,m</span><br><span class="line">l,s,r</span><br><span class="line">w,r</span><br><span class="line">xs,xf,fs,</span><br></pre></td></tr></table></figure><p>153900种情况（约6分钟）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gz</span><br><span class="line">,z,t,y,u,I,o,p,g,h,j,k,l,v,b,n,m,</span><br><span class="line">,d,s,h,x</span><br><span class="line">z,t,y,u,I,o,p,g,h,j,k,l,v,b,n,m,l,s,r</span><br><span class="line">z,t,y,u,I,o,p,g,h,j,k,l,v,b,n,m,w,r</span><br><span class="line">xs,xf,fs,xyqs,xqs</span><br></pre></td></tr></table></figure><p>均未果。</p><p>再后来，她觉得，大周末的也挺麻烦的，而且反正也不是什么重要的东西，文档也可以慢慢补回来，就决定放弃了。</p><p>尽管没能解决问题，也不重要了，给她带来的陪伴价值是很珍贵的，同时也让我有了一些破解经验。</p><h2 id="后续探索"><a class="markdownIt-Anchor" href="#后续探索"></a> 后续探索</h2><p>在闲暇之余，我开始去网上搜相关的文章博客论坛等等，看看别人的破解经验，在浏览了 20+ 篇的文章之后，发现了这么一个软件：<a href="https://www.hashcat.net" target="_blank" rel="noopener">hashcat</a>，自称是世界上最快的最先进的密码恢复工具，而且还开源免费，支持包括 MS Office 2013 在内的上百种类型的 hash 破解。</p><p>看了介绍就觉得是神器，我必须试试了。</p><h3 id="尝试用-hashcat-破解-linux-用户登录密码"><a class="markdownIt-Anchor" href="#尝试用-hashcat-破解-linux-用户登录密码"></a> 尝试用 hashcat 破解 linux 用户登录密码</h3><p>在 CSDN上 <a href="https://blog.csdn.net/qq_37865996/article/details/83863075" target="_blank" rel="noopener">hashcat的学习和使用记录</a> 这篇博客的引导下，我开始了第一次尝试，尝试实验破解 linux 的用户登录密码。</p><h4 id="建立测试用户"><a class="markdownIt-Anchor" href="#建立测试用户"></a> 建立测试用户</h4><p>首先，建立一个新用户 qwer，密码为 123456</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo useradd -m qwer</span><br><span class="line">sudo passwd qwer</span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后输入两次 123456</span></span><br></pre></td></tr></table></figure><p>尝试登录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su - qwer</span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后输入密码 123456</span></span><br></pre></td></tr></table></figure><p>登录成功。</p><h4 id="提取哈希"><a class="markdownIt-Anchor" href="#提取哈希"></a> 提取哈希</h4><p>我知道，用户的密码是哈希加密之后，放在了 /etc/shadow 里，这个文件对普通用户是没有读取权限的，只有 root 用户能访问，直接查看这文件，取得哈希。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cat /etc/shadow | grep qwer</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qwer:$6$teTb&#x2F;7A1JUDBJ3Ea$oU8XOGYd.nN96vi7x0yzFdrhQVk5IcK4AHn&#x2F;gKPcBFHuXtFtFsF64628pPQBI0yEeJH47E5jqLdgTZkYUR7Rs1:18225:0:99999:7:::</span><br></pre></td></tr></table></figure><p>保留 hashcat 所需要的值，去掉不需要的之后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$6$teTb&#x2F;7A1JUDBJ3Ea$oU8XOGYd.nN96vi7x0yzFdrhQVk5IcK4AHn&#x2F;gKPcBFHuXtFtFsF64628pPQBI0yEeJH47E5jqLdgTZkYUR7Rs1</span><br></pre></td></tr></table></figure><p>把这串值写到一个文本文件里，建个工作目录放进去吧</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd</span><br><span class="line">mkdir hashcat</span><br><span class="line">cd hashcat</span><br><span class="line">echo '$6$teTb/7A1JUDBJ3Ea$oU8XOGYd.nN96vi7x0yzFdrhQVk5IcK4AHn/gKPcBFHuXtFtFsF64628pPQBI0yEeJH47E5jqLdgTZkYUR7Rs1' &gt; hash.txt</span><br></pre></td></tr></table></figure><p>这样，哈希文件就准备好了。</p><h4 id="构造字典"><a class="markdownIt-Anchor" href="#构造字典"></a> 构造字典</h4><p>总得要构造个字典才能实验，虽然能直接指定掩码暴力的方式，但我更钟爱字典。</p><p>继续写个简易的 python 程序来构造一个字典吧</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line">it = itertools.product(<span class="string">'1234567890'</span>, repeat=<span class="number">6</span>)</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> it:</span><br><span class="line">print(<span class="string">''</span>.join(a))</span><br></pre></td></tr></table></figure><p>然后运行这个程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x gendict</span><br><span class="line">./gendict &gt; dict.txt</span><br></pre></td></tr></table></figure><p>然后看看正确密码在哪一行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat dict.txt | grep -n 123456</span><br></pre></td></tr></table></figure><p>得知在第 987655 行，要搜索这么多次，正好可以看看 hashcat 有多快。</p><h4 id="开始破解-2"><a class="markdownIt-Anchor" href="#开始破解-2"></a> 开始破解</h4><p>直接执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashcat -m 1800 -a 0 -o output.txt hash.txt dict.txt</span><br></pre></td></tr></table></figure><p>各参数解释</p><ol><li><strong>-m 1800</strong>  指定 hash 的类型的 id ，这里是破解 linux 密码所以 id 是 1800，通过 hashcat --help 可以看到解密不同类型 hash 的 id。</li><li><strong>-a 0</strong>  指定攻击模式， 0代表字典，3代表掩码暴力等等，这里直接指定字典。</li><li><strong>-o output.txt</strong>   指定破解出来之后，输出结果保存的文件。</li><li><strong>hash.txt</strong>  指定要破解的 hash 文件。</li><li><strong>dict.txt</strong>  指定字典。</li></ol><p>ok，按回车之后，提示失败，输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hashcat (v5.1.0) starting...</span><br><span class="line"></span><br><span class="line">clGetPlatformIDs(): CL_PLATFORM_NOT_FOUND_KHR</span><br><span class="line"></span><br><span class="line">Started: Wed Nov 25 22:20:45 2019</span><br><span class="line">Stopped: Wed Nov 25 22:20:45 2019</span><br></pre></td></tr></table></figure><p>这是为什么呢，百度了一下 clGetPlatformIDs 这个函数，查到应该是个 opencl 相关的函数，这个函数顾名思义，这是在寻找平台吗，也就是 hashcat 默认是要用 GPU 来破解计算的，哈哈，难怪堪称世界第一。那好嘛，我的 nvidia 显卡肯定是被大黄蜂禁用的状态，你会 not found 很正常咯，我直接启用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">optirun hashcat -m 1800 -a 0 -o output.txt hash.txt dict.txt</span><br></pre></td></tr></table></figure><p>这下好像成功了，开始破解了，虽然看到一些警告。</p><p>最后一行是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[s]tatus [p]ause [b]ypass [c]heckpoint [q]uit &#x3D;&gt;</span><br></pre></td></tr></table></figure><p>可以看出是几个选项，可以输首字母来操控，输入个 s 提示了以下信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Session..........: hashcat</span><br><span class="line">Status...........: Running</span><br><span class="line">Hash.Type........: sha512crypt $6$, SHA512 (Unix)</span><br><span class="line">Hash.Target......: $6$teTb&#x2F;7A1JUDBJ3Ea$oU8XOGYd.nN96vi7x0yzFdrhQVk5IcK...UR7Rs1</span><br><span class="line">Time.Started.....: Wed Nov 25 22:42:10 2019 (36 secs)</span><br><span class="line">Time.Estimated...: Wed Nov 25 23:10:08 2019 (27 mins, 22 secs)</span><br><span class="line">Guess.Base.......: File (dict.txt)</span><br><span class="line">Guess.Queue......: 1&#x2F;1 (100.00%)</span><br><span class="line">Speed.#1.........:      596 H&#x2F;s (10.19ms) @ Accel:32 Loops:16 Thr:32 Vec:1</span><br><span class="line">Recovered........: 0&#x2F;1 (0.00%) Digests, 0&#x2F;1 (0.00%) Salts</span><br><span class="line">Progress.........: 20480&#x2F;1000000 (2.05%)</span><br><span class="line">Rejected.........: 0&#x2F;20480 (0.00%)</span><br><span class="line">Restore.Point....: 20480&#x2F;1000000 (2.05%)</span><br><span class="line">Restore.Sub.#1...: Salt:0 Amplifier:0-1 Iteration:1968-1984</span><br><span class="line">Candidates.#1....: 080620 -&gt; 088583</span><br><span class="line">Hardware.Mon.#1..: Temp: 64c</span><br></pre></td></tr></table></figure><p>很容易读懂这些信息，我最关心的是速度，速度是 596 次每秒，那么…正确密码在 987655 行，算一算需要 27 分钟才能找到密码。</p><p>我只是想尝试一下而已，不想费那么久时间还烧显卡。直接输入 q 退出。然后手动打开字典改一改，把 123456 放到大概一万行的位置吧，然后再执行破解。</p><p>很快，执行结束了，出结果了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Session..........: hashcat</span><br><span class="line">Status...........: Cracked</span><br><span class="line">Hash.Type........: sha512crypt $6$, SHA512 (Unix)</span><br><span class="line">Hash.Target......: $6$teTb&#x2F;7A1JUDBJ3Ea$oU8XOGYd.nN96vi7x0yzFdrhQVk5IcK...UR7Rs1</span><br><span class="line">Time.Started.....: Wed Nov 25 22:50:57 2019 (21 secs)</span><br><span class="line">Time.Estimated...: Wed Nov 25 22:51:18 2019 (0 secs)</span><br><span class="line">Guess.Base.......: File (dict.txt)</span><br><span class="line">Guess.Queue......: 1&#x2F;1 (100.00%)</span><br><span class="line">Speed.#1.........:      602 H&#x2F;s (10.22ms) @ Accel:32 Loops:16 Thr:32 Vec:1</span><br><span class="line">Recovered........: 1&#x2F;1 (100.00%) Digests, 1&#x2F;1 (100.00%) Salts</span><br><span class="line">Progress.........: 12288&#x2F;1000000 (1.23%)</span><br><span class="line">Rejected.........: 0&#x2F;12288 (0.00%)</span><br><span class="line">Restore.Point....: 10240&#x2F;1000000 (1.02%)</span><br><span class="line">Restore.Sub.#1...: Salt:0 Amplifier:0-1 Iteration:4992-5000</span><br><span class="line">Candidates.#1....: 090860 -&gt; 098823</span><br><span class="line">Hardware.Mon.#1..: Temp: 67c</span><br><span class="line"></span><br><span class="line">Started: Wed Nov 25 22:50:37 2019</span><br><span class="line">Stopped: Wed Nov 25 22:51:19 2019</span><br></pre></td></tr></table></figure><p>在第二行 Status…: Cracked ，可以得知已经破解了。然后 ls 一下发现果然有个 output.txt，执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat output.txt</span><br></pre></td></tr></table></figure><p>看看结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$6$teTb&#x2F;7A1JUDBJ3Ea$oU8XOGYd.nN96vi7x0yzFdrhQVk5IcK4AHn&#x2F;gKPcBFHuXtFtFsF64628pPQBI0yEeJH47E5jqLdgTZkYUR7Rs1:123456</span><br></pre></td></tr></table></figure><p>好的，这次尝试很顺利，123456 被破解出来了。</p><h3 id="尝试用-hashcat-破解-excel-密码"><a class="markdownIt-Anchor" href="#尝试用-hashcat-破解-excel-密码"></a> 尝试用 hashcat 破解 excel 密码</h3><p>已经熟悉了 hashcat 的基本使用了，该用它试试满足我的需求了。</p><p>得知提取 office 文档的 hash 用的是开源的 office2john，可以直接下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;magnumripper&#x2F;JohnTheRipper&#x2F;raw&#x2F;bleeding-jumbo&#x2F;run&#x2F;office2john.py</span><br></pre></td></tr></table></figure><p>然后执行它，指定要破解的 xlsx 文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python office2john.py 2.xlsx &gt; 2.hash</span><br></pre></td></tr></table></figure><p>然后看看 2.hash 的内容，把开头的 2.xlsx 和冒号去掉。</p><p>用 hashcat --help 查询得知 office 2013 的加密方式 id 是 9600，那我可以用原来 python 生成的字典开始了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">optirun hashcat -m 9600 -a 0 -o output.txt 2.hash dict.txt</span><br></pre></td></tr></table></figure><p>很快，又跑起来了。看到，速度，只有？158 H/s ？？还没有 Advanced Office Password Recovery？ 说好的世界第一呢？</p><h3 id="严重失误的发现"><a class="markdownIt-Anchor" href="#严重失误的发现"></a> 严重失误的发现</h3><p>抱着好奇的态度，我再次打开 Advanced Office Password Recovery，然后打开 2.xlsx ，加载字典，然后开始，发现速度只有 16 H/s ？？</p><p>那么我前面那个实验得出的 400 次每秒是怎么回事，难道是我刚刚把电脑烧烫了，速度就慢了？那也不该慢这么多，我重复着之前的动作，发现，我之前一直加载的根本不是 2.xlsx ，而是用的我自己最开始实验的时候，用 excel 2007 加密的文档！我再次打开我那用来实验加密的 excel 2007 的文档，发现速度又是 400次每秒了。</p><p>也就是说，我后来帮她破解的时候，根本没有选对文件，我一直破解的是我自己加密的文档，这是一个严重的失误，导致我后续的暴力破解全都是无效的破解。</p><p>然后后续继续实验，作出对比总结</p><ol><li>用 Advanced Office Password Recovery ：<ol><li>破解 office 2007 速度为 400 H/s</li><li>破解 office 2013 速度为 16 H/s</li></ol></li><li>用 hashcat ：<ol><li>破解 office 2007 速度为 2221 H/s</li><li>破解 office 2013 速度为 158 H/s</li></ol></li></ol><p>用 GPU 计算确实速度快了不少，虽然我这是几年前的垃圾卡。</p><p>对于失误，我后来又重新用 hashcat 跑了一遍，之前生成的字典，那个15万次的用了半小时。然后发现 hashcat 有个细节很贴心</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Watchdog: Temperature abort trigger set to 90c</span><br></pre></td></tr></table></figure><p>温度超过 90 度时自动停止，休息一会，然后可以运行 hashcat --restore 来接着上次的破解，能很好的保护机器，后续探索发现会话保存在 ~/.hashcat/session 里面，也可以用命令行参数来指定会话的位置，看来，hashcat 是一个很成熟考虑周全的软件了，有时间的话，我会总结出它所有的功能用法，列出来以便以后使用。</p><p>发现失误后，用 hashcat 加载以前的字典，跑了半小时还是没跑出来，不过这次经历让我收获很多。</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>hashcat 能破解上百种类型的 hash，而且支持 GPU 运算，对高性能的显卡来说速度会更快。那么破解 hashcat 支持的 hash 类型，我把步骤程序化，以后遇到要破解的问题都按这个思路了。</p><ol><li><p><strong>提取要破解的 hash</strong></p><p>每种文档或者密码，提取 hash 的方式不同，以后遇到什么样的密码，可以现查资料。</p></li><li><p><strong>尽可能搜集多的关于密码的情报</strong></p><p>这一步主要是为了生成字典，尽可能了解多的信息，来缩小搜索范围。</p></li><li><p><strong>生成字典</strong></p><p>生成字典可以自己写 python 程序来实现，可以妙用迭代器来快速生成，也可以利用 crunch 等软件来生成字典。</p></li><li><p><strong>用 hashcat 开始破解</strong></p><p>破解的过程中可能出现温度过高的情况，那么可以用计划任务的方式尽情发挥想象力破解。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 探究学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 信息安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探索如何更方便的管理和部署 hexo 博客</title>
      <link href="/learn/hexo/management/"/>
      <url>/learn/hexo/management/</url>
      
        <content type="html"><![CDATA[<p>在学会使用 hexo 的基本操作后，发现使用和部署的过程中，遇到几个问题，在此罗列出来逐一解决。</p><a id="more"></a><h2 id="遇到的不便之处"><a class="markdownIt-Anchor" href="#遇到的不便之处"></a> 遇到的不便之处</h2><ol><li>由于使用很多主题的过程中，需要对 _config.yml、模块目录 node_modules 进行大量修改，当想要换主题时，得重新用新的 _config.yml ，如果模块不重装，则可能会有大量不需要的模块留下来。因此，要更换主题，不得不重新初始化建立博客目录，但是博客的源文件保存在 source 里面，重新 hexo init 初始化后，需要又需要保留原来的 source，同样，hexo deploy 部署用的是 .deploy_git 目录，需要备份。</li><li>每次 hexo init 时会克隆 hexo-starter 和 hexo-theme-landscape 仓库，而 landscape 主题很大，国内克隆这个大仓库耗费时间，而这个仓库是默认主题，通常是不需要的。</li><li>每次 hexo init 后都需要 npm install 来安装模块。</li><li>在使用的过程中，如果 source 放到本机，要是本机故障或者突发情况导致 source 目录没了，那么损失会惨重。</li></ol><h2 id="解决思路"><a class="markdownIt-Anchor" href="#解决思路"></a> 解决思路</h2><p>对于以上问题，想出一些一劳永逸的解决思路。</p><ol><li>对所有需要保存的重要的东西，托管到 github。</li><li>改用 npm 来直接从淘宝镜像站自动安装 hexo，并且安装其依赖，写成一个脚本，大幅度提升效率。</li><li>本地存一份保存重要的东西的仓库，包括 source 目录，将 source 目录用符号链接的方式链接到博客的主目录。</li><li>将 .deploy_git 放到自己的本地 github 仓库目录 ，同样用符号链接的方式链接到博客的主目录。</li><li>将主题目录的改动也记录到此仓库，用符号链接的方式对应过去，这里来可以妙用 cp 的 -s 参数。</li><li>以上一切可以使用 shell 脚本来自动化，快速快速更换主题，同时 shell 脚本本身也可以算作重要的东西托管到 github。</li></ol><h2 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案</h2><h3 id="建立重要的仓库"><a class="markdownIt-Anchor" href="#建立重要的仓库"></a> 建立重要的仓库</h3><p>在 github 上建立一个仓库名为 fkxxyz-blog-src 的仓库，用来保存重要的信息，如配置好的初始 _config.yml 、source 目录、自动化脚本，其中， _config.yml 保存两份，一份是由默认的 _config.yml 模板修改成自己的信息得到，取名为 _config-fkxxyz.yml，一份是由 _config-fkxxyz.yml 修改成当前使用的主题相关的配置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 克隆刚建好的空仓库</span></span><br><span class="line">cd ~/github.com/fkxxyz</span><br><span class="line">git clone https://github.com/fkxxyz/fkxxyz-blog-src.git</span><br><span class="line">ls</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 保存重要信息到这个仓库</span></span><br><span class="line">cd fkxxyz-blog-src</span><br><span class="line">cp -r ~/myblog/source .</span><br><span class="line">cp ~/myblog/_config.yml _config-fkxxyz.yml</span><br><span class="line">cp ~/myblog/_config.yml .</span><br><span class="line">touch README.md</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交上传仓库</span></span><br><span class="line">git add -A</span><br><span class="line">git commit -m 'first commit'</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><h3 id="编写一键脚本"><a class="markdownIt-Anchor" href="#编写一键脚本"></a> 编写一键脚本</h3><p>首先设计这个脚本，这个脚本放在 fkxxyz-blog-src 仓库目录中运行，功能是解压指定的博客目录模板压缩包到特定位置，脚本名为 setup。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/github.com/fkxxyz/fkxxyz-blog-src</span><br><span class="line">touch setup</span><br><span class="line">chmod +x setup</span><br></pre></td></tr></table></figure><p>然后编写 setup，由于以后随时会更新完善，实时内容详见 <a href="https://github.com/fkxxyz/fkxxyz-blog-src/blob/master/setup" target="_blank" rel="noopener">https://github.com/fkxxyz/fkxxyz-blog-src/blob/master/setup</a></p><p>为了方便起见再编写两个脚本 gen 和 push， gen 用于复制修改过主题到目标目录，并且一键 hexo clean、hexo generate；push 用于一键 hexo deploy 。</p><p>最后，不忘把此仓库复制到服务器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add -A</span><br><span class="line">git commit -m update</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><h2 id="测试解决效果"><a class="markdownIt-Anchor" href="#测试解决效果"></a> 测试解决效果</h2><p>现在，所有的一切工作都可以在 ~/github.com/fkxxyz/fkxxyz-blog-src 目录里进行了，首先切换到此目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/github.com/fkxxyz/fkxxyz-blog-src</span><br></pre></td></tr></table></figure><p>下面开始逐一测试效果。</p><h3 id="更换主题"><a class="markdownIt-Anchor" href="#更换主题"></a> 更换主题</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./setup</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后下载 jacman 主题，放到 ~/hexo/themes/jacman</span></span><br></pre></td></tr></table></figure><h3 id="生成网站"><a class="markdownIt-Anchor" href="#生成网站"></a> 生成网站</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./gen</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后根据提示打开浏览器，进入地址 http://localhost:4000 进行测试。</span></span><br></pre></td></tr></table></figure><h3 id="上传改动"><a class="markdownIt-Anchor" href="#上传改动"></a> 上传改动</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./push</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后打开浏览器，输入自己域名 www.fkxxyz.com 查看效果。</span></span><br></pre></td></tr></table></figure><h3 id="写博客"><a class="markdownIt-Anchor" href="#写博客"></a> 写博客</h3><p>一切写博客的操作都在当前目录的 source 里，手动复制模板来完成，写完之后，可以 ./gen 生成然后测试，然后 ./push 上传。</p><h2 id="尾声"><a class="markdownIt-Anchor" href="#尾声"></a> 尾声</h2><p>这下可算是大功告成了，以后再也不怕换主题了，也不会怕丢失什么了，以后终于能够把一切精里放在写博客上了，达到了一劳永逸的效果。</p><p>接下来，我打算把我以前写的 md 文档，一个一个格式化，放到此博客上。</p>]]></content>
      
      
      <categories>
          
          <category> 探究学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> archlinux </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探究在 archlinux 上用 hexo 建立个人的博客</title>
      <link href="/learn/hexo/"/>
      <url>/learn/hexo/</url>
      
        <content type="html"><![CDATA[<p>archlinux 的官方仓库里面没有 hexo 这个包，而 aur 里有个，但是装了之后发现一些问题导致一头雾水，目录也很乱，不得不自己想办法探究探究原理，要明白彻底一点问题才能解决。</p><a id="more"></a><h2 id="探究-hexo-如何在-archlinux-上运行"><a class="markdownIt-Anchor" href="#探究-hexo-如何在-archlinux-上运行"></a> 探究 hexo 如何在 archlinux 上运行</h2><p>首先看看<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">官方文档</a>得知 <em>Hexo</em>是一个用 node.js 实现的博客框架，然后看了 <a href="https://wiki.archlinux.org/index.php/Node.js_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">node.js的archwiki</a> 得知，npm 是 node.js 的包管理器 。</p><p>然后根据 wiki 上描述装上 nodejs 和 npm</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S nodejs npm</span><br></pre></td></tr></table></figure><p>然后习惯性查看他们的信息和目录结构</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pacman -Qi nodejs</span><br><span class="line">pacman -Qi npm</span><br><span class="line">pacman -Ql nodejs</span><br><span class="line">pacman -Ql npm</span><br></pre></td></tr></table></figure><p>根据输出结果，发现一个庞大的目录 /usr/lib/node_modules，进去瞧瞧</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/lib/node_modules</span><br><span class="line">ls</span><br><span class="line">find</span><br></pre></td></tr></table></figure><p>显而易见的是，安装的 node.js 模块都被放在 /usr/lib/node_modules 里，里面每个子目录对应一个 node.js 模块，一开始有三个模块 node-gyp、npm、semver。</p><p>再看看这个 /usr/lib/node_modules 目录都有那些 archlinux 的软件包包含</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -Qo .</span><br></pre></td></tr></table></figure><p>更加确定了模块都是装在这个目录里，而且一个 archlinux 的软件包对应一个 node.js 模块，正如 python3.8 的模块都是装在 /usr/lib/python3.8/site-packages 里一样。</p><p>那么 npm 和 node.js 的关系，正如 pip 和 python 的关系一样。</p><p>类比一下可知，要装 hexo ，就得把 hexo 也打成 archlinux 的包，hexo 模块应该被放在 /usr/lib/node_modules/hexo 里。</p><p>首先看看 aur 里面有没有这样一个包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay hexo</span><br></pre></td></tr></table></figure><p>发现已经有了，包名是 nodejs-hexo，直接安装。装完后看看结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pacman -Ql hexo</span><br><span class="line">ls -l /usr/lib/node_modules</span><br><span class="line">hexo</span><br></pre></td></tr></table></figure><p>虽然能用，但是发现问题很大，/usr/lib/node_modules/hexo 的所有者是当前用户，而不是 root，可能打包的人的失误，也可能是使用的过程中需要修改这个目录？我觉得打包的人的失误可能性要大一些，毕竟这是模块目录怎么会被用户随便改。于是打算以后再解决这个问题，自己写 PKGBUILD，先能用了，建成了博客再说。</p><h2 id="安装-hexo"><a class="markdownIt-Anchor" href="#安装-hexo"></a> 安装 hexo</h2><p>暂时这么安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S nodejs-hexo</span><br></pre></td></tr></table></figure><h2 id="建站"><a class="markdownIt-Anchor" href="#建站"></a> 建站</h2><p>根据 <a href="https://hexo.io/zh-cn/docs/setup" target="_blank" rel="noopener">hexo的官方建站文档</a> ，由于第一次建，没经验，先测试，建立到 /tmp 目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /tmp/a</span><br><span class="line">cd /tmp/a</span><br><span class="line">hexo init myfolder</span><br></pre></td></tr></table></figure><p>等了很久之后，才结束，根据提示信息得知，hexo init 命令干了两件事：</p><ol><li>将 <a href="https://github.com/hexojs/hexo-starter.git" target="_blank" rel="noopener">https://github.com/hexojs/hexo-starter.git</a> 克隆到 /tmp/a/myfolder</li><li>将 <a href="https://github.com/hexojs/hexo-theme-landscape.git" target="_blank" rel="noopener">https://github.com/hexojs/hexo-theme-landscape.git</a> 克隆到 /tmp/a/myfolder/themes/landscape</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd myfolder</span><br><span class="line">ls</span><br><span class="line">find</span><br><span class="line">npm install</span><br><span class="line">find</span><br></pre></td></tr></table></figure><p>前后对比发现，npm install 这条命令可能是补充了所有 node.js 模块到 /tmp/a/myfolder/node_modules 里。</p><p>然后通过官网介绍，加上自己百度，大概得知了这里面大概各个目录的作用：</p><ol><li>config.yml 网站相关的配置文件</li><li>package.json 一开始不知道干嘛的，不过看内容可以猜测出，这整个目录是个应用程序，需要依赖很多模块，而这些所要依赖的模块放在 node_modules 里。</li><li>node_modules 整个应用程序所有依赖的模块，由 npm 管理。</li><li>scaffold 模板，大概是新建文章的时候要用。</li><li>source 应该是个人写的所有东西都在这里面，平时写东西都在这写 md 格式的文章，图片也往这放。</li><li>themes 顾名思义主题。</li><li>public 可能是将 source 的东西翻译建成网站之后的结果，一系列 html 文件，最终要发布的结果。</li></ol><p>大概了解后进入下一章。</p><h2 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h2><p>根据 <a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">官方文档-配置</a> ，编辑 _config.yml，里面的数据随便填写。通过这个页面，我得知：</p><ol><li>所有自定义配置围绕着这个文件修改。</li><li>可以配合域名，设置网站主页地址</li><li>原来 source、public 的目录位置都可以改，非常灵活。</li><li>连配置文件本身都能用参数额外指定。</li></ol><h2 id="尝试各种命令"><a class="markdownIt-Anchor" href="#尝试各种命令"></a> 尝试各种命令</h2><p>根据 <a href="https://hexo.io/zh-cn/docs/commands" target="_blank" rel="noopener">官方文档-命令</a> ，开始一条一条尝试里面的命令。</p><h3 id="init"><a class="markdownIt-Anchor" href="#init"></a> init</h3><p>上面已经试过。</p><h3 id="new"><a class="markdownIt-Anchor" href="#new"></a> new</h3><p>新建一篇文章，文章名为“第一篇文章”</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new 第一篇文章</span><br></pre></td></tr></table></figure><p>看看效果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find | grep 第一篇文章</span><br></pre></td></tr></table></figure><p>果然，在 source 里面找到了 <a href="http://xn--4gq868cp8oviaw0a.md" target="_blank" rel="noopener">第一篇文章.md</a> 这个文件。</p><p>接下来实验各种参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new 第二篇文章 -s wwwwwwwwwwwww</span><br><span class="line">hexo new 33333 -p aaa/bbb</span><br></pre></td></tr></table></figure><p>然后检查所有的变化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">grep -rn wwwwwwwwwwwww</span><br><span class="line">find | grep wwwwwwwwwwwww</span><br><span class="line">grep -rn 33333</span><br><span class="line">find | grep aaa/bbb</span><br><span class="line">grep -rn aaa/bbb</span><br></pre></td></tr></table></figure><p>发现所有改动全在 source 这个目录里。</p><p>那么得出结论，hexo new 这条命令本质是在 source/_posts 里面创建相应的 md 文件，我完全可以自己手动创建这些文件，和 hexo new 命令达到同样的效果。</p><p>查看这些文件内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat source/_posts/第一篇文章.md</span><br></pre></td></tr></table></figure><p>发现是不是和前面模板文件内容类似呢</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat scaffolds/post.md</span><br></pre></td></tr></table></figure><h3 id="generate"><a class="markdownIt-Anchor" href="#generate"></a> generate</h3><p>直接执行试试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure><p>生成静态文件，顾名思义是把 sources 里面所有的东西，处理成了 html 文件放在了 public 目录里，检验猜想</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find public</span><br></pre></td></tr></table></figure><p>恩？有 index.html ，好奇用浏览器打开试一下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chromium public/index.html</span><br></pre></td></tr></table></figure><p>哈啊，看到一个简陋的架子，也许是没把主题加上。继续往后看吧。</p><h3 id="server"><a class="markdownIt-Anchor" href="#server"></a> server</h3><p>直接执行试试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>然后浏览器里面输入网址</p><blockquote><p><a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a></p></blockquote><p>这下看到主题了，也能看到自己刚刚创建的 第一篇文章、第二篇文章、33333，还有最初始的 Hello World</p><p>联想到 github 提供的仓库可以建成网站，那我现在是不是就可以把 public 这个目录上传上去了呢，但是静态网站会不会加上主题呢？说试试就试试：</p><p>打开 github 网站登录自己的帐号 fkxxyz，根据要求创建一个仓库名是 <a href="http://fkxxyz.github.io">fkxxyz.github.io</a> 的仓库，然后找个地方开始动手</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir /tmp/b</span><br><span class="line">cd /tmp/b</span><br><span class="line">git clone https://github.com/fkxxyz/fkxxyz.github.io.git</span><br><span class="line">cp -r /tmp/a/myfolder/public/* .</span><br><span class="line">git add -A</span><br><span class="line">git commit -m update</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>一顿操作之后，打开 <a href="https://fkxxyz.github.io/">https://fkxxyz.github.io/</a> 果然，出现了网站。</p><p>那么我把自己的域名 <a href="http://www.fkxxyz.com" target="_blank" rel="noopener">www.fkxxyz.com</a> 解析到这个网址，博客等于已经建成了。</p><h3 id="deploy"><a class="markdownIt-Anchor" href="#deploy"></a> deploy</h3><p>直接执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>好像没什么用，查资料据之后，发现这条命令是代替上述一顿操作，能自动把 public 上传到 github 中自己的仓库，何乐而不为？直接看相应的官方介绍 <a href="https://hexo.io/zh-cn/docs/github-pages" target="_blank" rel="noopener">github-pages</a> 和 <a href="https://hexo.io/docs/one-command-deployment" target="_blank" rel="noopener">one-command-deployment</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /tmp/a/myfolder</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 安装模块</span></span></span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>修改 _config.yml ，将最后改成</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">https://github.com/fkxxyz/fkxxyz.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>然后再执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>这下有反应了，大功告成。</p><p>下篇文章准备写个教程总结，整理一下，今天探索到的一切。</p>]]></content>
      
      
      <categories>
          
          <category> 探究学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> archlinux </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 python 实现 xmind 和 mindjet 格式互转</title>
      <link href="/d/mmconv/"/>
      <url>/d/mmconv/</url>
      
        <content type="html"><![CDATA[<p>一直想找一款跨平台的免费又好用的思维导图软件，可是哪有两全其美的事呢，个人感觉安卓版的 mindjet 相对好用一些，windows 和 linux 版的 xmind 相对好用一些，但是 xmind 和 mindjet 的格式肯定是不兼容的，而探索发现，他们的文档解压之后都是以 xml 方式储存的，压缩也是简单的 zip 压缩，也没有任何加密，于是，故事开始了。</p><a id="more"></a><h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><p>经过大概八小时的开发后，这样一个转换器成功诞生。这是一款用 python3 实现的简单的 xmind 与 mindjet 格式之间的互转工具，只保留树状思维导图以及折叠功能，另外还可以额外可以转化成 txt，用缩进来表示树状图。</p><p>后来发现 xmind-zen 保存的文档无法在 xmind8 中打开，所以又添加了 xmind-zen 文档的支持。</p><p>项目已放到 github 开源，以便保存和后续随时修改。</p><p><a href="https://github.com/fkxxyz/mmconv" target="_blank" rel="noopener">https://github.com/fkxxyz/mmconv</a></p><h2 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h2><h3 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h3><p>利用 python 的列表嵌套列表来储存思维导图的树状结构，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">o</span><br><span class="line">├── a</span><br><span class="line">│   ├── 1</span><br><span class="line">│   ├── 2</span><br><span class="line">│   └── 3</span><br><span class="line">├── b</span><br><span class="line">└── c</span><br></pre></td></tr></table></figure><p>以上树状结构在代码中被储存为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'o'</span>,</span><br><span class="line"> <span class="literal">False</span>,</span><br><span class="line"> [[<span class="string">'a'</span>, <span class="literal">False</span>, [[<span class="string">'1'</span>, <span class="literal">False</span>, []], [<span class="string">'2'</span>, <span class="literal">False</span>, []], [<span class="string">'3'</span>, <span class="literal">False</span>, []]]],</span><br><span class="line">  [<span class="string">'b'</span>, <span class="literal">False</span>, []],</span><br><span class="line">  [<span class="string">'c'</span>, <span class="literal">False</span>, []]]]</span><br></pre></td></tr></table></figure><p>其中 <code>False</code> 表示未被折叠</p><h3 id="各个文档格式的存取"><a class="markdownIt-Anchor" href="#各个文档格式的存取"></a> 各个文档格式的存取</h3><ol><li><p>xmind 8</p><p>xmind 8 保存的格式是 zip 格式，解压后得到若干个文件，树状图数据以 xml 格式保存在 content.xml 里面。</p></li><li><p>xmind-zen</p><p>xmind-zen 保存的格式是 zip 格式，解压后得到若干个文件，树状图数据以 json 格式保存在 content.json 里面。</p></li><li><p>Mindjet Maps</p><p>Mindjet Maps 保存的格式是 zip 格式，解压后得到一个文件 Document.xml，树状图数据以 xml 格式保存在其中。</p></li><li><p>txt</p><p>这是我自己创建的文本文档格式方便调试储存和转换，用缩进的方式表示树状图，用垂直制表符表示是否被折叠</p></li></ol><p>代码风格易扩展，后续随时可以添加更多格式的支持，可以在 Issues 里面提出，有时间我会补充。</p><h2 id="用法"><a class="markdownIt-Anchor" href="#用法"></a> 用法</h2><h3 id="命令格式"><a class="markdownIt-Anchor" href="#命令格式"></a> 命令格式</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mmconv.py 源文件 [目标文件] [-t 格式]</span><br></pre></td></tr></table></figure><p>参数详解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">位置参数：</span><br><span class="line">  源文件                 表示要转换的文件。</span><br><span class="line">  目标文件               目标文件名。转换成功的保存的文件路径。</span><br><span class="line">                       如果未指定目标文件，则直接打印源文件类型。</span><br><span class="line"></span><br><span class="line">可选参数：</span><br><span class="line">  -h, --help            显示此帮助消息并退出</span><br><span class="line">  --type &#123;txt,mmap,xmind,zen&#125;, -t &#123;txt,mmap,xmind,zen&#125;</span><br><span class="line">                        指定目标文件的类型。目前支持以下类型：</span><br><span class="line">                        xmind - XMind 8 文档</span><br><span class="line">                        zen - XMind zen 文档</span><br><span class="line">                        txt - txt 文本文档</span><br><span class="line">                        mmap - Mindjet maps 文档</span><br></pre></td></tr></table></figure><p>若未指定 --type 类型参数，则默认为 txt。</p><p>源文件的格式不用指定，会自己识别，详见 --help</p><h3 id="用法示例"><a class="markdownIt-Anchor" href="#用法示例"></a> 用法示例</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将 a.xmind 转换成 txt 格式</span></span><br><span class="line">mmconv.py a.xmind a.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将 a.xmind 转换成 mmap 格式</span></span><br><span class="line">mmconv.py -t mmap a.xmind a.mmap</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将 a.txt 转换成 xmind 格式</span></span><br><span class="line">mmconv.py -t xmind a.txt a.xmind</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将 a.xmind 转换成 xmind-zen 格式</span></span><br><span class="line">mmconv.py -t zen a.xmind b.xmind</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 原创开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 思维导图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>任意 linux 发行版下用 wine 安装 office2007 完美运行</title>
      <link href="/c/wine/office2007/"/>
      <url>/c/wine/office2007/</url>
      
        <content type="html"><![CDATA[<p>在 linux 下，尝试过各种办公软件之后，总是和微软的 office 格式有些差异，怎么也找不到完美的 office 替代品。</p><p>于是想到了 wine，配合谷歌和百度之后，得知在众多 office 版本中，wine 对 office 2007 这个版本支持是最完美的，于是开始了折腾之路，产生了这篇教程。</p><a id="more"></a><h2 id="下载-office2007-的官方-iso-光盘镜像"><a class="markdownIt-Anchor" href="#下载-office2007-的官方-iso-光盘镜像"></a> 下载 office2007 的官方 iso 光盘镜像</h2><p>个人推荐亲测可用的 office2007 镜像 <a href="http://www.songyongzhi.com/Office2007.html" target="_blank" rel="noopener">http://www.songyongzhi.com/Office2007.html</a></p><h2 id="安装-wine"><a class="markdownIt-Anchor" href="#安装-wine"></a> 安装 wine</h2><p>各大发行版安装 wine 的方法不同，可以自己百度或谷歌其安装方法。下面介绍 archlinux 和 deepin 两个的发行版安装 wine 的方法。</p><h3 id="archlinux-发行版中安装-wine"><a class="markdownIt-Anchor" href="#archlinux-发行版中安装-wine"></a> archlinux 发行版中安装 wine</h3><p>启用 multilib 仓库，编辑 /etc/pacman.conf，取消下面内容的注释，此步骤详见官方wiki <a href="https://wiki.archlinux.org/index.php/Official_repositories_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#multilib" target="_blank" rel="noopener">官方仓库multilib</a></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[multilib]</span></span><br><span class="line"><span class="attr">Include</span> = /etc/pacman.d/mirrorlist</span><br></pre></td></tr></table></figure><p>然后使用包管理器安装 wine</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S wine</span><br></pre></td></tr></table></figure><hr /><h3 id="deepin-发行版中安装-wine"><a class="markdownIt-Anchor" href="#deepin-发行版中安装-wine"></a> deepin 发行版中安装 wine</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install wine</span><br></pre></td></tr></table></figure><h2 id="验证-wine-是否安装成功"><a class="markdownIt-Anchor" href="#验证-wine-是否安装成功"></a> 验证 wine 是否安装成功</h2><p>终端中执行 wine，如果提示类似以下信息，则代表安装成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Usage: wine PROGRAM [ARGUMENTS...]   Run the specified program</span><br><span class="line">       wine --help                   Display this help and exit</span><br><span class="line">       wine --version                Output version information and exit</span><br></pre></td></tr></table></figure><h2 id="安装-winetricks"><a class="markdownIt-Anchor" href="#安装-winetricks"></a> 安装 winetricks</h2><p>对于archlinux，官方仓库有winetricks所以能直接安装，直接执行 sudo pacman -S winetricks 即可</p><p>对于其他发行版，可以手动下载安装（以下步骤若是执行出错，提示缺少什么就装什么，如 wget 命令未找到，就用包管理器安装 wget）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装依赖的组建</span></span><br><span class="line">sudo apt-get install cabextract</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载仓库</span></span><br><span class="line">wget https://github.com/Winetricks/winetricks/archive/master.zip</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压仓库</span></span><br><span class="line">unzip master.zip</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入仓库目录</span></span><br><span class="line">cd winetricks-master</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装到系统</span></span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 清理刚刚下载、解压的文件</span></span><br><span class="line">cd ..</span><br><span class="line">rm -r winetricks-master</span><br><span class="line">rm master.zip</span><br></pre></td></tr></table></figure><p>检验 winetricks 是否安装成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">winetricks --help</span><br></pre></td></tr></table></figure><p>显示出很多帮助信息，则安装成功。</p><h2 id="建立一个自定义的-office2007-的-wine-容器"><a class="markdownIt-Anchor" href="#建立一个自定义的-office2007-的-wine-容器"></a> 建立一个自定义的 office2007 的 wine 容器</h2><p>在家目录中随便找个位置用于保存 office2007 的容器安装目录，下面以 ~/wine/office2007 为例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置 wine 的环境变量</span></span><br><span class="line">WINEPREFIX=~/wine/office2007</span><br><span class="line">WINEARCH=win32</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 建立容器目录</span></span><br><span class="line">winecfg</span><br></pre></td></tr></table></figure><p>在弹出的 wine设置中，最好将 windows 版本设置成 Windows XP，然后点确定。</p><p>然后开始用 winetrick 安装 office2007</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 挂载安装光盘，注意把下载好的iso文件替换成你实际下载好的路径</span></span><br><span class="line">sudo mount &lt;下载的iso文件路径&gt; /mnt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开始安装 office2007</span></span><br><span class="line">winetricks office2007pro</span><br></pre></td></tr></table></figure><p>在弹出的安装界面中可以像 windows 下一样一步一步正常安装，注意要点</p><ol><li>许可协议中方块字体可以不用管，不影响后续使用。</li><li>安装过程中注意挑选自己安装的组建即可，一般只勾选三件套 word excel ppt 以及公共的共享功能和工具。</li><li>安装路径默认 C:\Program Files\Microsoft Office 即可，会自动映射到你前面所设置的 wine 容器目录中。</li><li>一般情况下装装完之后，应用菜单列表中即可启动正常使用office。</li></ol><h2 id="后续需要的设置"><a class="markdownIt-Anchor" href="#后续需要的设置"></a> 后续需要的设置</h2><p>在 word 中输入法可能不能正常使用，如果遇到此情况，打开 word 选项–高级–输入法控制处于活动状态勾勾打上</p><h2 id="关于字体"><a class="markdownIt-Anchor" href="#关于字体"></a> 关于字体</h2><p>linux 里面是没有 windows 字体的，这会导致很多方块现象和想用的字体没有的情况。需要导入 windows 字体才可以正常使用 windows 字体。<br />如果你目前装有现成的 windows 系统，可以从 windows 字体目录中复制到 linux 直接使用。<br /><em>注： windows 的字体在 windows 分区下 Windows/fonts 里面，linux 的字体在 /usr/share/fonts 里面，只需要复制所有的 ttf 格式字体即可</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 任意在 /usr/share/fonts 下建立一个子目录</span></span><br><span class="line">sudo mkdir -p /usr/share/fonts/windows</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将 windows 字体复制过来</span></span><br><span class="line">sudo cp &lt;windows分区挂载点&gt;/Windows/fonts/*.ttf /usr/share/fonts/windows</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新字体缓存</span></span><br><span class="line">cd /usr/share/fonts/windows</span><br><span class="line">sudo mkfontscale</span><br><span class="line">sudo mkfontdir</span><br><span class="line">sudo fc-cache</span><br></pre></td></tr></table></figure><p>重启 office 生效</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> archlinux </tag>
            
            <tag> linux </tag>
            
            <tag> wine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>archlinux 下 nvidia 双显卡配置--大黄蜂方案</title>
      <link href="/c/nvidia/"/>
      <url>/c/nvidia/</url>
      
        <content type="html"><![CDATA[<p>双显卡切换的问题是难倒很多新手的问题，我也是那么折腾过来的，<a href="https://wiki.archlinux.org/index.php/Bumblebee_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">大黄蜂的wiki</a> 也有详细的介绍，本文做一个速记总结。</p><a id="more"></a><h2 id="安装-nvidia-内核模块"><a class="markdownIt-Anchor" href="#安装-nvidia-内核模块"></a> 安装 nvidia 内核模块</h2><h3 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h3><p>用包管理器安装英伟达显卡驱动（如果显卡较老加载不成功则可尝试nvidia-390xx，更老则可搜索aur里的驱动安装 nvidia-340xx ，注意后面加了 -390xx 之后，后面所有带 nvidia 的包名都得加 -390xx，其它以此类推）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pacman -S nvidia nvidia-utils</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 若是 390xx 的，则包名为 nvidia-390xx nvidia-390xx-utils</span></span><br></pre></td></tr></table></figure><p>32位程序程序使用英伟达显卡驱动支持（记得需要<a href="https://wiki.archlinux.org/index.php/Official_repositories_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#multilib" target="_blank" rel="noopener">开启 multilib 仓库</a>）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pacman -S lib32-nvidia-utils</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 若是 390xx 的，则包名为 lib32-nvidia-390xx-utils</span></span><br></pre></td></tr></table></figure><p>尝试加载驱动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">modprobe nvidia nvidia_uvm nvidia_drm nvidia_modeset</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果这一步报错，则卸载刚刚装的所有，回到第一步，尝试其它驱动。</span></span><br></pre></td></tr></table></figure><h3 id="测试"><a class="markdownIt-Anchor" href="#测试"></a> 测试</h3><p>查看驱动是否在运行（有输出代表成功运行）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lsmod | grep nvidia</span><br><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure><p>查看显卡所有信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvidia-smi -q</span><br></pre></td></tr></table></figure><h2 id="安装-bbswitch"><a class="markdownIt-Anchor" href="#安装-bbswitch"></a> 安装 bbswitch</h2><h3 id="安装-2"><a class="markdownIt-Anchor" href="#安装-2"></a> 安装</h3><p>安装显卡驱动开关</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S bbswitch</span><br></pre></td></tr></table></figure><h3 id="启动"><a class="markdownIt-Anchor" href="#启动"></a> 启动</h3><p>加载显卡驱动开关</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modprobe bbswitch</span><br></pre></td></tr></table></figure><h3 id="测试-2"><a class="markdownIt-Anchor" href="#测试-2"></a> 测试</h3><p>把开关打开</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tee /proc/acpi/bbswitch &lt;&lt;&lt; ON</span><br></pre></td></tr></table></figure><p>把开关关闭</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tee /proc/acpi/bbswitch &lt;&lt;&lt; OFF</span><br></pre></td></tr></table></figure><p>查看开关状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/acpi/bbswitch</span><br></pre></td></tr></table></figure><h2 id="安装大黄蜂"><a class="markdownIt-Anchor" href="#安装大黄蜂"></a> 安装大黄蜂</h2><h3 id="安装-3"><a class="markdownIt-Anchor" href="#安装-3"></a> 安装</h3><p>安装配置双显卡切换器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S bumblebee</span><br></pre></td></tr></table></figure><h3 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h3><p>将自己用户加入到 bumblebee 组（注销重新登录后生效）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -a -G bumblebee &lt;用户名&gt;</span><br></pre></td></tr></table></figure><p>修改 /etc/bumblebee/bumblebee.conf :</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Driver</span>=nvidia</span><br><span class="line"><span class="section">[driver-nvidia]</span></span><br><span class="line"><span class="attr">PMMethod</span>=bbswitch</span><br></pre></td></tr></table></figure><h3 id="启动-2"><a class="markdownIt-Anchor" href="#启动-2"></a> 启动</h3><p>启动服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start bumblebeed</span><br></pre></td></tr></table></figure><p>设置服务自动启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable bumblebeed</span><br></pre></td></tr></table></figure><h3 id="测试-3"><a class="markdownIt-Anchor" href="#测试-3"></a> 测试</h3><p>测试英伟达显卡驱动（不加optirun为测试集显，终端输出了显卡型号，以后用optirun运行程序则表示使用英伟达显卡）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">optirun glxspheres64</span><br><span class="line">optirun glxspheres32</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> archlinux </tag>
            
            <tag> 双显卡切换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 Archlinux 下从 AUR 装的 xmind 启动报错的问题探究</title>
      <link href="/learn/xmind-error/"/>
      <url>/learn/xmind-error/</url>
      
        <content type="html"><![CDATA[<p>电脑版的思维导图软件，我还是最钟爱 xmind，然而在 archlinux 下从 AUR 构建 xmind 直接启动之后报错。</p><a id="more"></a><h2 id="问题描述"><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h2><ol><li><p>安装完之后，直接点击图标直接启动，弹出以下对话框。</p><p><img src="/img/xmind-error.png" alt="xmind-error" /></p></li><li><p>在安装 XMind 时，输出的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">正在加载软件包...</span><br><span class="line">正在解析依赖关系...</span><br><span class="line">正在查找软件包冲突...</span><br><span class="line"></span><br><span class="line">软件包 (1) xmind-3.7.8+8update8-1</span><br><span class="line"></span><br><span class="line">全部安装大小：  125.02 MiB</span><br><span class="line"></span><br><span class="line">:: 进行安装吗？ [Y&#x2F;n] </span><br><span class="line">(1&#x2F;1) 正在检查密钥环里的密钥                        [###########################] 100%</span><br><span class="line">(1&#x2F;1) 正在检查软件包完整性                          [###########################] 100%</span><br><span class="line">(1&#x2F;1) 正在加载软件包文件                            [###########################] 100%</span><br><span class="line">(1&#x2F;1) 正在检查文件冲突                              [###########################] 100%</span><br><span class="line">(1&#x2F;1) 正在检查可用存储空间                          [###########################] 100%</span><br><span class="line">:: 正在处理软件包的变化...</span><br><span class="line">(1&#x2F;1) 正在安装 xmind                                [###########################] 100%</span><br><span class="line">If XMind crashed on start, trying delete ~&#x2F;.xmind</span><br><span class="line"></span><br><span class="line">If you want to change gtk version or java version, please edit PKGBUILD and rebuild the package. Or edit &#x2F;usr&#x2F;share&#x2F;xmind&#x2F;XMind&#x2F;XMind.ini, change number to your gtk version after &quot;--launcher.GTK_version&quot;, and add&#x2F;delete &quot;--add-modules&#x3D;java.se.ee&quot; at the end of file if you use java 10&#x2F;8.</span><br><span class="line">xmind 的可选依赖</span><br><span class="line">    gtk2: gtk2 or gtk3 must install one [已安装]</span><br><span class="line">    gtk3: gtk2 or gtk3 must install one [已安装]</span><br><span class="line">    lame: needed for the feature audio notes [已安装]</span><br><span class="line">:: 正在运行事务后钩子函数...</span><br><span class="line">(1&#x2F;6) Arming ConditionNeedsUpdate...</span><br><span class="line">(2&#x2F;6) Updating fontconfig cache...</span><br><span class="line">(3&#x2F;6) Updating 32-bit fontconfig cache...</span><br><span class="line">(4&#x2F;6) Updating the desktop file MIME type cache...</span><br><span class="line">(5&#x2F;6) Updating the MIME type database...</span><br><span class="line">(6&#x2F;6) Updating X fontdir indices...</span><br></pre></td></tr></table></figure></li></ol><h2 id="问题探究"><a class="markdownIt-Anchor" href="#问题探究"></a> 问题探究</h2><h3 id="常规思考"><a class="markdownIt-Anchor" href="#常规思考"></a> 常规思考</h3><p>由打包者提示的信息，基本可以猜测，是 java 运行环境的问题，以及启动参数 --add-modules=<a href="http://java.se.ee" target="_blank" rel="noopener">java.se.ee</a> 的问题。</p><p>那么尝试从命令行启动，看看有没有报错信息吧，先找到对应的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pacman -Ql xmind | grep desktop</span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出 xmind /usr/share/applications/xmind.desktop</span></span><br><span class="line"></span><br><span class="line">cat /usr/share/applications/xmind.desktop | grep Exec</span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出 Exec=XMind %F</span></span><br></pre></td></tr></table></figure><p>得知启动命令是 XMind，那么直接执行 XMind 试试之后，得到如下报错，同时弹出上面那错误对话框。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Unrecognized option: --add-modules&#x3D;java.se.ee</span><br><span class="line">Error: Could not create the Java Virtual Machine.</span><br><span class="line">Error: A fatal exception has occurred. Program will exit.</span><br></pre></td></tr></table></figure><p>提示很明显，不识别的参数 --add-modules=<a href="http://java.se.ee" target="_blank" rel="noopener">java.se.ee</a>，结合上面安装的时候给的信息，去编辑 /usr/share/xmind/XMind/XMind.ini，发现里面有 --add-modules=<a href="http://java.se.ee" target="_blank" rel="noopener">java.se.ee</a> 这一行，把这一行删掉。</p><p>然后再输入 XMind ，发现启动成功！</p><h3 id="深入探究"><a class="markdownIt-Anchor" href="#深入探究"></a> 深入探究</h3><p>抱着追根究低的态度继续思考，–add-modules=<a href="http://java.se.ee" target="_blank" rel="noopener">java.se.ee</a> 有什么意义呢为什么会被加上？再细细读打包者给出的信息的最后一句话</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">and add&#x2F;delete &quot;--add-modules&#x3D;java.se.ee&quot; at the end of file if you use java 10&#x2F;8.</span><br></pre></td></tr></table></figure><p>很容易猜出，java 10 可能支持 --add-modules=<a href="http://java.se.ee" target="_blank" rel="noopener">java.se.ee</a>，而 java 8 不支持。</p><p>看看当前的系统中的 java 版本吧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><p>果然是 1.8 版本。</p><p>那么我们装个 java 10 试试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S java-runtime&#x3D;10</span><br></pre></td></tr></table></figure><p>然后用 java 切换脚本（详见 <a href="https://wiki.archlinux.org/index.php/Java_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">java的archwiki</a>），切换成 java 10</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 列出系统中所有 java 环境</span><br><span class="line">archlinux-java status</span><br><span class="line"></span><br><span class="line"># 切换 java 10 为默认环境</span><br><span class="line">sudo archlinux-java set java-10-openjdk</span><br><span class="line"></span><br><span class="line"># 查看切换结果</span><br><span class="line">archlinux-java status</span><br><span class="line">java -version</span><br></pre></td></tr></table></figure><p>然后再试试启动 XMind，发现启动不了了，如下弹窗报错</p><p><img src="/img/xmind-error1.png" alt="xmind-error1" /></p><p>去看这个日志，发现一大堆，因为没学过太多 java，所以看不懂也并不想看。</p><p>直接把 --add-modules=<a href="http://java.se.ee" target="_blank" rel="noopener">java.se.ee</a> 加回 /usr/share/xmind/XMind/XMind.ini 再试试启动，发现启动成功。</p><p>也就是验证了前面猜测是正确的：</p><ol><li>在 java 8 的环境下，不能有 --add-modules=<a href="http://java.se.ee" target="_blank" rel="noopener">java.se.ee</a></li><li>在 java 10 的环境下，必须有 --add-modules=<a href="http://java.se.ee" target="_blank" rel="noopener">java.se.ee</a></li></ol><h2 id="修改-pkgbuild-重新打包"><a class="markdownIt-Anchor" href="#修改-pkgbuild-重新打包"></a> 修改 PKGBUILD 重新打包</h2><p>我再打开这个包的 PKGBUILD 一看，发现有 JAVA_VERSION=10 语句，然后 package 函数里有 if [[ “$JAVA_VERSION” != “8” ]]; then 来决定是否往里写 --add-modules=<a href="http://java.se.ee" target="_blank" rel="noopener">java.se.ee</a></p><p>但是就算在这里改了 JAVA_VERSION 这个变量，那谁知道用户的机子里默认的是 java8 还是 java10 呢？这里 JAVA_VERSION 设置的是 10 ，而大多数用户默认肯定是 8，这么一来，岂不是对新手很不友好？</p><p>有没有更好的打包方案呢，有，我觉得可以这样做：</p><ol><li><p>将依赖行为 depends=(‘java-runtime&gt;=8’) 改成 depends=(“java-runtime=$JAVA_VERSION”)</p></li><li><p>将启动脚本里面加上一行对应的 PATH 变量来显式指定 java 环境。</p><p>即在最后一行 cp ${srcdir}/XMind              ${pkgdir}/usr/bin/ 后面加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#39;&#x2F;exec&#x2F;iPATH&#x3D;&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-&#39;&quot;$JAVA_VERSION&quot;&#39;-openjdk&#x2F;bin:$PATH&#39; $&#123;pkgdir&#125;&#x2F;usr&#x2F;bin&#x2F;XMind</span><br></pre></td></tr></table></figure></li></ol><p>至此，观察到里面选择 gtk2 还是 gtk3 也是同样的道理。</p><p>最终给出我修改后完整的 PKGBUILD</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="variable">$Id</span>: PKGBUILD 184754 2016-08-01 15:30:30Z felixonmars $</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Maintainer: RemiliaForever &lt;remilia AT koumakan DOT cc&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Contributor: Felix Yan &lt;felixonmars@gmail.com&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Contributor: Christoph Drexler &lt;chrdr at gmx dot at&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Contributor: Jelle van der Waa &lt;jellevdwaa@gmail.com&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> GTK_VERSION 2/3</span></span><br><span class="line">GTK_VERSION=3</span><br><span class="line"><span class="meta">#</span><span class="bash"> JAVA_VERSION 8/10</span></span><br><span class="line">JAVA_VERSION=10</span><br><span class="line"></span><br><span class="line">pkgname=xmind</span><br><span class="line">pkgver=3.7.8+8update8</span><br><span class="line">_filename=$pkgname-8-update8-linux</span><br><span class="line">pkgrel=1</span><br><span class="line">pkgdesc="Brainstorming and Mind Mapping Software"</span><br><span class="line">arch=('i686' 'x86_64')</span><br><span class="line">url="http://www.xmind.net"</span><br><span class="line">license=('EPL' 'LGPL')</span><br><span class="line">depends=("java-runtime=$JAVA_VERSION" "gtk$GTK_VERSION")</span><br><span class="line">optdepends=('lame: needed for the feature audio notes')</span><br><span class="line">install=xmind.install</span><br><span class="line">source=("http://www.xmind.net/xmind/downloads/$&#123;_filename&#125;.zip"</span><br><span class="line">'XMind'</span><br><span class="line">'xmind.desktop'</span><br><span class="line">'xmind.xml'</span><br><span class="line">'xmind.png'</span><br><span class="line">'xmind_file.png')</span><br><span class="line">sha512sums=('77c5c05801f3ad3c0bf5550fa20c406f64f3f5fa31321a53786ac1939053f5c4f0d0fb8ab1af0a9b574e3950342325b9c32cf2e9a11bf00a1d74d2be1df75768'</span><br><span class="line">'SKIP'</span><br><span class="line">'SKIP'</span><br><span class="line">'SKIP'</span><br><span class="line">'SKIP'</span><br><span class="line">'SKIP')</span><br><span class="line"></span><br><span class="line">package() &#123;</span><br><span class="line">    mkdir -p $&#123;pkgdir&#125;/usr/share/$&#123;pkgname&#125;</span><br><span class="line">    cp -r $&#123;srcdir&#125;/configuration   $&#123;pkgdir&#125;/usr/share/$&#123;pkgname&#125;/</span><br><span class="line">    cp -r $&#123;srcdir&#125;/features        $&#123;pkgdir&#125;/usr/share/$&#123;pkgname&#125;/</span><br><span class="line">    cp -r $&#123;srcdir&#125;/plugins         $&#123;pkgdir&#125;/usr/share/$&#123;pkgname&#125;/</span><br><span class="line">    cp $&#123;srcdir&#125;/*.xml              $&#123;pkgdir&#125;/usr/share/$&#123;pkgname&#125;/</span><br><span class="line">    mkdir -p $&#123;pkgdir&#125;/usr/share/licenses/$&#123;pkgname&#125;</span><br><span class="line">    cp $&#123;srcdir&#125;/&#123;epl-v10,lgpl-3.0&#125;.html    $&#123;pkgdir&#125;/usr/share/licenses/$&#123;pkgname&#125;/</span><br><span class="line">    cp $&#123;srcdir&#125;/xpla.txt                   $&#123;pkgdir&#125;/usr/share/licenses/$&#123;pkgname&#125;/</span><br><span class="line">    if [[ "$CARCH" == "i686" ]]; then</span><br><span class="line">        cp -r $&#123;srcdir&#125;/XMind_i386  $&#123;pkgdir&#125;/usr/share/$&#123;pkgname&#125;/XMind</span><br><span class="line">    else</span><br><span class="line">        cp -r $&#123;srcdir&#125;/XMind_amd64 $&#123;pkgdir&#125;/usr/share/$&#123;pkgname&#125;/XMind</span><br><span class="line">    fi</span><br><span class="line">    mkdir -p $&#123;pkgdir&#125;/usr/share/fonts/$&#123;pkgname&#125;</span><br><span class="line">    cp -r $&#123;srcdir&#125;/fonts           $&#123;pkgdir&#125;/usr/share/fonts/$&#123;pkgname&#125;/</span><br><span class="line">    mkdir -p $&#123;pkgdir&#125;/usr/share/applications</span><br><span class="line">    cp $&#123;srcdir&#125;/xmind.desktop      $&#123;pkgdir&#125;/usr/share/applications/</span><br><span class="line">    mkdir -p $&#123;pkgdir&#125;/usr/share/mime/packages</span><br><span class="line">    cp $&#123;srcdir&#125;/xmind.xml          $&#123;pkgdir&#125;/usr/share/mime/packages/</span><br><span class="line">    mkdir -p $&#123;pkgdir&#125;/usr/share/pixmaps</span><br><span class="line">    cp $&#123;srcdir&#125;/*.png              $&#123;pkgdir&#125;/usr/share/pixmaps/</span><br><span class="line">    # fix configuration</span><br><span class="line">    sed -i "s|^./configuration$|@user.home/.xmind/configuration|" $&#123;pkgdir&#125;/usr/share/$&#123;pkgname&#125;/XMind/XMind.ini</span><br><span class="line">    sed -i "s|^../workspace$|@user.home/.xmind/workspace|" $&#123;pkgdir&#125;/usr/share/$&#123;pkgname&#125;/XMind/XMind.ini</span><br><span class="line">    if [[ "$GTK_VERSION" != "2" ]]; then</span><br><span class="line">        sed -i "s|^2$|3|" $&#123;pkgdir&#125;/usr/share/$&#123;pkgname&#125;/XMind/XMind.ini</span><br><span class="line">    fi</span><br><span class="line">    if [[ "$JAVA_VERSION" != "8" ]]; then</span><br><span class="line">        echo "--add-modules=java.se.ee" &gt;&gt; $&#123;pkgdir&#125;/usr/share/$&#123;pkgname&#125;/XMind/XMind.ini</span><br><span class="line">    fi</span><br><span class="line">    mkdir -p $&#123;pkgdir&#125;/usr/bin</span><br><span class="line">    cp $&#123;srcdir&#125;/XMind              $&#123;pkgdir&#125;/usr/bin/</span><br><span class="line">    sed -i '/exec/iPATH=/usr/lib/jvm/java-'"$JAVA_VERSION"'-openjdk/bin:$PATH' $&#123;pkgdir&#125;/usr/bin/XMind</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后可以随意修改 GTK_VERSION 和 JAVA_VERSION 来达到目的，并且还不用额外修改任何东西，无论如何切换默认 java 版本，都不会再影响启动了。</p><p>重新打包测试，成功。</p>]]></content>
      
      
      <categories>
          
          <category> 探究学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> archlinux </tag>
            
            <tag> 思维导图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NetworkManager 网络配置速查</title>
      <link href="/c/nm/"/>
      <url>/c/nm/</url>
      
        <content type="html"><![CDATA[<p>一般普通用户上网的方式无非就三种：有线以太网、无线网络、宽带PPPOE拨号。而 NetworkManager 这个软件将以上三种方式集成一体，而且配置方便。</p><a id="more"></a><p>NetworkManager 是 gnome 桌面环境自带的网络管理服务，在 tty 的命令行中也可以运行，刚装完的系统，想要网络，只需要装这一个包就够！</p><p>因此写这篇文章作为一个速查备忘和新手入门，更高级的用法可以自己查看 nmcli 自带的 --help 。</p><h2 id="服务管理"><a class="markdownIt-Anchor" href="#服务管理"></a> 服务管理</h2><p>启动网络管理器服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start NetworkManager</span><br></pre></td></tr></table></figure><p>将此服务设为自动启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable NetworkManager</span><br></pre></td></tr></table></figure><h2 id="全局管理"><a class="markdownIt-Anchor" href="#全局管理"></a> 全局管理</h2><p>查看网络概况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nmcli</span><br><span class="line">nmcli -overview</span><br></pre></td></tr></table></figure><p>打开关闭总网络开关</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nmcli n on/off</span><br><span class="line">nmcli network on/off</span><br></pre></td></tr></table></figure><h2 id="设备管理"><a class="markdownIt-Anchor" href="#设备管理"></a> 设备管理</h2><p>查看网络设备状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nmcli d</span><br><span class="line">nmcli device</span><br><span class="line">nmcli device status</span><br></pre></td></tr></table></figure><p>查看网络设备详细信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nmcli d sh</span><br><span class="line">nmcli device show</span><br><span class="line">nmcli device show eth0</span><br></pre></td></tr></table></figure><p>连接/断开设备</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mncli d conn/dis eth0</span><br><span class="line">mncli device connect/disconnect eth0</span><br></pre></td></tr></table></figure><p>删除软件设备</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli d del</span><br></pre></td></tr></table></figure><p>监控某个设备的连接过程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nmcli d mon eth0</span><br><span class="line">nmcli d monitor eth0</span><br></pre></td></tr></table></figure><p>设置某个设备自动连接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli d set eth0 auto yes/no</span><br></pre></td></tr></table></figure><p>设置某个设备是否本程序管理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli d set eth0 man yes/no</span><br></pre></td></tr></table></figure><p>配置某个设备（暂时的，重启失效）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli d mod eth0 ??</span><br></pre></td></tr></table></figure><p>让某个设备重新应用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mncli d re eth0</span><br></pre></td></tr></table></figure><p>查询wifi</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nmcli d wifi</span><br><span class="line">nmcli d wifi list</span><br><span class="line">nmcli d wifi list ifname wlp3s0</span><br></pre></td></tr></table></figure><p>刷新wifi</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nmcli d wifi rescan</span><br><span class="line">nmcli d wifi rescan ifname wlp3s0</span><br></pre></td></tr></table></figure><p>连接wifi</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nmcli d wifi connect &lt;SSID&gt; password &lt;password&gt;</span><br><span class="line">nmcli d wifi connect &lt;SSID&gt; password &lt;password&gt; ifname wlp3s0</span><br></pre></td></tr></table></figure><h2 id="配置管理"><a class="markdownIt-Anchor" href="#配置管理"></a> 配置管理</h2><p>查看所有配置<br />所有配置文件保存在 /etc/NetworkManager/system-connections</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nmcli c</span><br><span class="line">nmcli c show</span><br></pre></td></tr></table></figure><p>删除某个配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli c del &lt;name&gt;</span><br></pre></td></tr></table></figure><p>复制某个配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli c clone &lt;name&gt; &lt;new_name&gt;</span><br></pre></td></tr></table></figure><p>连接/断开某个配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli c up/down &lt;name&gt;</span><br></pre></td></tr></table></figure><p>重新载入配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli c reload</span><br></pre></td></tr></table></figure><p>导入/导出配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli ??</span><br></pre></td></tr></table></figure><p>监视某个配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli c mon &lt;name&gt;</span><br></pre></td></tr></table></figure><p>修改某个配置的某一行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli c mod &lt;name&gt; &lt;配置&gt;.&lt;属性&gt; &lt;值&gt;</span><br></pre></td></tr></table></figure><p>启动编辑某个配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli c edit &lt;name&gt;</span><br></pre></td></tr></table></figure><p>创建配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli c add con-name &lt;name&gt; type ??? ...</span><br></pre></td></tr></table></figure><p>创建pppoe拨号配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli c add con-name &lt;name&gt; type pppoe ifname &lt;设备&gt; username &lt;username&gt; password &lt;password&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> archlinux </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>archlinux 的基本配置</title>
      <link href="/c/base/"/>
      <url>/c/base/</url>
      
        <content type="html"><![CDATA[<p>本文速记一些刚装完 archlinux 之后所需的必要配置，以便以后速查。</p><a id="more"></a><h2 id="基本配置"><a class="markdownIt-Anchor" href="#基本配置"></a> 基本配置</h2><h3 id="设置键盘布局"><a class="markdownIt-Anchor" href="#设置键盘布局"></a> 设置键盘布局</h3><p>列出所有可用的键盘布局</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /usr/share/kbd/keymaps/**/*.map.gz</span><br></pre></td></tr></table></figure><p>设置想要的键盘布局（默认 us，只需指定文件名即可，无需拓展名）<br />loadkeys us<br />设置键盘布局<br />写入文件 /etc/vconsole.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KEYMAP&#x3D;us</span><br></pre></td></tr></table></figure><h3 id="设置时区"><a class="markdownIt-Anchor" href="#设置时区"></a> 设置时区</h3><p>设置为上海时区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br></pre></td></tr></table></figure><h3 id="设置系统时间"><a class="markdownIt-Anchor" href="#设置系统时间"></a> 设置系统时间</h3><p>（以下两个二选一）<br />将硬件时间设置为系统的本地时间（与windows默认相同）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hwclock -s -l</span><br></pre></td></tr></table></figure><p>将硬件时间设置为系统的UTC时间（与mac系统默认相同）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hwclock -s -u</span><br></pre></td></tr></table></figure><p>启用 ntp 服务，获取网络时间并设置为当前系统时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timedatectl set-ntp true</span><br></pre></td></tr></table></figure><p>生成时间偏差（/etc/adjtime）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hwclock -w</span><br></pre></td></tr></table></figure><h3 id="设置本地语言"><a class="markdownIt-Anchor" href="#设置本地语言"></a> 设置本地语言</h3><p>修改 /etc/locale.gen，去除en_US.UTF-8和zh_CN.UTF-8前面的井号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">locale-gen</span><br><span class="line">echo LANG&#x3D;en_US.UTF-8 &gt;&#x2F;etc&#x2F;locale.conf</span><br></pre></td></tr></table></figure><h3 id="修改主机名"><a class="markdownIt-Anchor" href="#修改主机名"></a> 修改主机名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hostnamectl set-hostname ???</span><br></pre></td></tr></table></figure><p>在 /etc/hosts 里添加（设置网络主机名）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1          localhost</span><br><span class="line">::1                localhost</span><br><span class="line">127.0.1.1          ???.localdomain ???</span><br></pre></td></tr></table></figure><h3 id="用户管理"><a class="markdownIt-Anchor" href="#用户管理"></a> 用户管理</h3><p>设置 root 用户的密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd root</span><br></pre></td></tr></table></figure><p>创建新用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -m ???</span><br></pre></td></tr></table></figure><h3 id="sudo"><a class="markdownIt-Anchor" href="#sudo"></a> sudo</h3><p>将 /etc/sudoers 中 %wheel 前面的 去掉</p><p>将某用户设成管理员（能够用sudo）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -a -G wheel ???</span><br></pre></td></tr></table></figure><h3 id="配置软件源"><a class="markdownIt-Anchor" href="#配置软件源"></a> 配置软件源</h3><p>参见：</p><ol><li><a href="https://mirrors.tuna.tsinghua.edu.cn/help/archlinux/" target="_blank" rel="noopener">Arch Linux 软件仓库镜像使用帮助</a></li><li><a href="https://mirrors.tuna.tsinghua.edu.cn/help/archlinuxcn/" target="_blank" rel="noopener">ArchlinuxCN 镜像使用帮助</a></li></ol><p>更新软件数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -Syy</span><br></pre></td></tr></table></figure><p>更新系统</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -Syu</span><br></pre></td></tr></table></figure><p>开启别的仓库只需要取消注释 /etc/pacman.conf 相应的项，参见 <a href="https://wiki.archlinux.org/index.php/Official_repositories_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">archwiki-官方仓库</a></p><h2 id="高级配置"><a class="markdownIt-Anchor" href="#高级配置"></a> 高级配置</h2><h3 id="禁用-beep-响铃"><a class="markdownIt-Anchor" href="#禁用-beep-响铃"></a> 禁用 beep 响铃</h3><p>在 tty 下敲命令会时不时的发出 beep 声音，超级大声很烦，必须禁掉。</p><p>暂时生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmmod pcspkr</span><br></pre></td></tr></table></figure><p>永久生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo blacklist pcspkr&gt;&gt;&#x2F;etc&#x2F;modprobe.d&#x2F;nobeep.conf</span><br></pre></td></tr></table></figure><h3 id="禁用-nouveau-驱动"><a class="markdownIt-Anchor" href="#禁用-nouveau-驱动"></a> 禁用 nouveau 驱动</h3><p>此驱动bug过多，可能导致死机，花屏，卡顿等未知故障。<br />在 /etc/modprobe.d/no-nouveau.conf 中写入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">blacklist nouveau</span><br><span class="line">options nouveau modeset&#x3D;0</span><br></pre></td></tr></table></figure><h3 id="禁用蓝牙"><a class="markdownIt-Anchor" href="#禁用蓝牙"></a> 禁用蓝牙</h3><p>如果蓝牙没怎么用过，禁了会省电些</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &#x2F;lib&#x2F;modules&#x2F;&#96;uname -r&#96;&#x2F;kernel -name bluetooth|xargs find|grep \.xz$|awk -F&#39;&#x2F;&#39; &#39;&#123;print $NF&#125;&#39;|awk -F&#39;.&#39; &#39;&#123;print &quot;blacklist &quot; $1&#125;&#39; &gt;&gt;&#x2F;etc&#x2F;modprobe.d&#x2F;no-bluetooth.conf</span><br></pre></td></tr></table></figure><h3 id="解开-rf-锁"><a class="markdownIt-Anchor" href="#解开-rf-锁"></a> 解开 rf 锁</h3><p>用查看 wifi 的 rf锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rfkill list</span><br></pre></td></tr></table></figure><p>解除 rf 锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rfkill unblock all</span><br></pre></td></tr></table></figure><h3 id="开启-sysrq"><a class="markdownIt-Anchor" href="#开启-sysrq"></a> 开启 sysrq</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo kernel.sysrq = 1 &gt; /etc/sysctl.d/sysrq.conf</span><br></pre></td></tr></table></figure><p>该功能默认关闭，开启后对于死机时候防止硬盘损坏尤其管用。参见 <a href="https://www.kernel.org/doc/html/latest/admin-guide/sysrq.html" target="_blank" rel="noopener">官方文档sysrq</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> archlinux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 python 自制需求列表来进行包管理，从此再也不用重装系统</title>
      <link href="/d/spacman/"/>
      <url>/d/spacman/</url>
      
        <content type="html"><![CDATA[<h2 id="问题背景"><a class="markdownIt-Anchor" href="#问题背景"></a> 问题背景</h2><p>archlinux 是个可高度定制的 linux 发行版，在使用的过程中，需要反复测试很多软件包的功能，以达到自己想要的效果，效果不好的卸载，用得好的留下，但由于依赖是复杂的树状结构，时间长了，容易忘记自己测试过哪些包，以至于有些包只是临时安装的后来忘了卸载，随着积累容易导致在系统里留下大量不必要的包。</p><p>pacman 的功能之一是可以查询安装原因，安装原因有两种“单独指定安装”和“作为其他软件包的依赖关系安装”，也可以通过 pacman -Qdt 找出所有没必要的依赖包，pacman -Qe 可以列出所有自己显式指定安装过的包，还可以通过 pacman -Rscn 卸载某个软件来将其不必要的依赖也同时卸载。</p><p>虽然 pacman 功能强大，但依然没法满足以上需求，因为很多包都是自己指定安装，但是后来忘了自己只是临时测试这个包，测试过应当卸载，然而这类包显然留在系统中，这些包还不容易被找到，要是数量庞大，基本只能重装系统才能完全干净。</p><p>强迫症患者们当然希望自己的系统是干干净净，只有自己需要的包，没有其它任何垃圾包。</p><p>于是有了新的脚本需求…</p><a id="more"></a><h2 id="需求设计"><a class="markdownIt-Anchor" href="#需求设计"></a> 需求设计</h2><p>需要这样一个脚本，这个脚本能实现：</p><ol><li>能够从一个文本文档里面读取软件列表（不包含“作为其他软件包的依赖关系安装”的包，只需要指定<strong>顶层包</strong>），根据此列表与系统已安装的包进行对比，进行依赖计算，列出所有多余的包，列出所有指定了却未安装的包。</li><li>软件列表可以有以井号开头的注释，可以忽略空行，每行包含一个软件包。这样可以方便测试注释。</li><li>设计命令行参数，在必要时可以指定不同的配置文件，也可以指定自己喜欢的包管理器命令如 yay ，让脚本自动调用包管理器来同步软件列表和系统。</li></ol><h3 id="能满足的需求"><a class="markdownIt-Anchor" href="#能满足的需求"></a> 能满足的需求</h3><p>要是真的实现了这样一个脚本，用处非常大，我在此罗列几点，充分发挥想象力的话，能带来无尽的乐趣。</p><ol><li><p>**能根据自己的需要完全掌控系统的包：**把自己所有需要的软件做成列表（不需要考虑底层依赖），而且能对每一行的包名后面用井号注释一些自己想写的，让自己一目了然，也让系统里面出了这些包及其依赖的包之外不存在其它任何包，轻而易举地掌控系统的所有包，实现随心所欲高度定制。</p></li><li><p>**大幅度方便增删测试：**想测试一批软件时，只需要编辑这个软件列表，在里面添加若干行想要测试的软件，然后应用到系统，然后开始随便玩，等当不想用这些软件了，就注释或删掉那些行，再应用到系统，这些软件无影无踪，依赖也一个不留。</p><p>比如我想测试 deepin 的桌面环境，先执行 pacman -Sqg deepin 看看有哪些包，直接把这些包名复制到列表里，然后应用到系统…测完了从列表里删去，再应用到系统，完美回到没测试之前的样子。</p></li><li><p>**当成系统还原点：**只要我改变列表不变，那么我可以随意安装测试任何软件包，比如装 deepin 组，装任意多的包哪怕装了几十G碎碎的包，玩够了之后，直接应用列表，刚刚装的几十G直接在一分钟之内无影无踪一个不漏，完全回到测试以前的样子，此方法就是将一个列表看作是一个还原点，甚至可以设置多个还原点（多个列表）进行任意测试，配合 pacman 的装卸极速特性，基本可以随便玩了。</p></li></ol><h2 id="项目实现"><a class="markdownIt-Anchor" href="#项目实现"></a> 项目实现</h2><h3 id="实现思路"><a class="markdownIt-Anchor" href="#实现思路"></a> 实现思路</h3><p>选择用 python来实现，因为 python的列表和字典非常好用，先从系统中读取所有软件包的信息，放到一个巨大的列表里，然后将每个软件包名作为字典的键，构建出一个大字典，然后对依赖进行整合，然后同样对列表里所有包进行这样处理，算出一个所需的包的集合，将系统里所有包也弄成一个集合，将两个集合直接相减，也就算出了所有多余的包了。</p><p>以下难点一个一个被攻破：</p><ol><li><p><strong>难点：</strong> 读取所有软件包信息，转换成 python 列表。</p><p><strong>解决：</strong> 模拟执行 LANG=C pacman -Qi ，然后字符串处理。</p></li><li><p><strong>难点：</strong> 某些包的依赖（Depends On）是一些包的提供字段（Provides）。</p><p>**解决：**利用字典的索引特性，把每个 Depends On 的内容转换成具体包名。</p></li><li><p><strong>难点：</strong> 某些包的依赖（Depends On）是版本号的对比，比如 java-runtime&gt;=8，而版本由好几个段组成，比较算法可能过于复杂。</p><p>**解决：**查询 libalpm 的开发文档得知，里面有个 C 库函数 alpm_pkg_vercmp 被封装在 <a href="http://libalpm.so" target="_blank" rel="noopener">libalpm.so</a> 中，直接模拟调用，版本比较问题解决。</p></li></ol><p>本项目已经用 python3 实现，我将它取名为超级包管理器，脚本名称为 <a href="https://github.com/fkxxyz/spacman" target="_blank" rel="noopener">spacman</a> ，放在 github 上开源托管。方便以后直接调用，已经自己打包上传到了 aur，可以用 yay 直接安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S spacman</span><br></pre></td></tr></table></figure><p>所有强迫症患者的福音！</p><h2 id="用法"><a class="markdownIt-Anchor" href="#用法"></a> 用法</h2><h3 id="命令语法"><a class="markdownIt-Anchor" href="#命令语法"></a> 命令语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">用法: spacman [-h] [--config 列表文件] [--pacman 包管理器] [--apply] [--query]</span><br><span class="line"></span><br><span class="line">可选参数:</span><br><span class="line">  -h, --help            显示帮助信息</span><br><span class="line"> --config 列表文件, -c 列表文件</span><br><span class="line">                        指定列表文件（默认为 ~&#x2F;.config&#x2F;spacman&#x2F;default.conf）</span><br><span class="line">  --pacman 包管理器, -p 包管理器</span><br><span class="line">                        指定包管理器（例如 yay，默认为 pacman）</span><br><span class="line">  --apply, -a           自动调用包管理器，将列表应用到系统</span><br><span class="line">  --query, -q           查询一个列表中所有的包</span><br></pre></td></tr></table></figure><p>以上用法可能已经过时没有更新，详见 spacman --help</p><p>用法举例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将 ~/.config/spacman/default.conf 列表与系统已安装的包进行对比，输出结果</span></span><br><span class="line">spacman</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将 ~/spacman1.conf 作为列表进行对比，输出结果</span></span><br><span class="line">spacman -c ~/spacman1.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将 ~/.config/spacman/default.conf 列表应用到系统</span></span><br><span class="line">spacman -a</span><br><span class="line"><span class="meta">#</span><span class="bash"> 警告，万万不可将空列表应用到系统，否则会卸载所有软件包</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将 ~/.config/spacman/default.conf 列表应用到系统，并用 yay 作为包管理器</span></span><br><span class="line">spacman -a -p yay</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出 ~/.config/spacman/default.conf 列表中所有软件包并排序</span></span><br><span class="line">spacman -q | sort</span><br></pre></td></tr></table></figure><h3 id="如何写配置"><a class="markdownIt-Anchor" href="#如何写配置"></a> 如何写配置</h3><p>到底该如何写配置文件呢，首先要自己总结出自己所有需要的包列表，写到一个文本文档里，只需要写你需要的包，不需要操心任何依赖，一行一个，格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">linux</span><br><span class="line">linux-firmware</span><br><span class="line">base</span><br><span class="line">grub</span><br><span class="line">dhcpcd</span><br><span class="line">iw</span><br><span class="line">wpa_supplicant</span><br><span class="line">archlinuxcn-keyring</span><br><span class="line">yay</span><br></pre></td></tr></table></figure><p>当然为了你的方便，你可以把配置文件当成笔记，顺便记录linux软件包名和功能，井号开头注释即可，也可以在包名后面跟井号注释，空行随意</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 内核</span></span><br><span class="line">linux</span><br><span class="line">linux-firmware  # 固件</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 基本</span></span><br><span class="line">base</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 引导器</span></span><br><span class="line">grub</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 网络</span></span><br><span class="line">dhcpcd    # dhcp客户端</span><br><span class="line">iw   # 无线管理</span><br><span class="line">wpa_supplicant  # 无线加密</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 源</span></span><br><span class="line">archlinuxcn-keyring</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> aur helper</span></span><br><span class="line">yay</span><br></pre></td></tr></table></figure><p>如果嫌麻烦，可以用 pacman -Qe 快速生成一个列表，这命令表示列出所有自己用pacman主动安装的包名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -Qe &gt; a.conf</span><br></pre></td></tr></table></figure><p>但是不建议这样做，因为生成的列表是按字母排序，而且自己整理注释起来麻烦，还不如自己从头写个。</p><p>我的日常列表也托管到 github 了，可以随时参考 <a href="https://github.com/fkxxyz/archlinux-config/blob/master/spacman/spacman.conf" target="_blank" rel="noopener">spacman.conf</a></p><h3 id="使用逻辑"><a class="markdownIt-Anchor" href="#使用逻辑"></a> 使用逻辑</h3><p>我暂时想出以下使用方法，大家可以尽情的发挥想象发挥更多的潜力。</p><ol><li>当成个人做的笔记记录，用linux用久了自己也记不清自己需要哪些包，配置文件可以刚好帮你记录。</li><li>配置列表中，自己想删去哪个包了，可以井号注释掉，而不必删掉一行，然后 spacman -a 即可，以后想反悔直接去掉井号注释，再次 spacman -a</li><li>可以把所有自己可能需要的同类软件包都记录下来，然后都用井号注释掉，然后想用哪个直接去掉哪个的井号。</li><li>实验各个软件，而不加进列表，只把满意的软件加进列表，不满意的由于没加进列表，直接 spacman -a 会删掉所有没进列表的软件包括其依赖，而不必一个一个 pacman -Rsc 卸载，省心又高效。例如实验各个桌面环境，一个gnome桌面环境有多少个顶层包咱们也知道。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 原创开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> archlinux </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
